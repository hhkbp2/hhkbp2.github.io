<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>
            
                    Lisp on
                
            
            hhkbp2&#39;s blog</title>
        <link>https://hhkbp2.com/categories/lisp/</link>
        <description>Recent content  in Lisp
            on hhkbp2&#39;s blog</description>
        <language>en-us</language>
        <lastBuildDate>Sun, 17 Sep 2023 18:23:56 +0800</lastBuildDate>
        <generator>Hugo -- gohugo.io</generator>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
            <atom:link href="https://hhkbp2.com/categories/lisp/index.xml" rel="self" type="application/rss&#43;xml" />
        
            
            <item>
                <title>Kapok 的设计与实现: Protocol</title>
                <link>https://hhkbp2.com/kapok-the-design-and-implementation-of-protocol/</link>
                
                
                <description>&lt;p&gt;&lt;a href=&#34;https://github.com/kapok-lang/kapok&#34;&gt;Kapok&lt;/a&gt;是我设计与实现的一个基于Erlang VM的现代Lisp编程语言。&lt;a href=&#34;https://hhkbp2.com/blog/2016/06/08/minds-echo/&#34;&gt;《念念不忘，亦有回响》&lt;/a&gt;这篇文章叙述了这门编程语言的概况。下面我们来聊一聊其中Protocol的具体设计和实现。&lt;/p&gt;

&lt;h2 id=&#34;protocol是什么&#34;&gt;Protocol是什么&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#protocol%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;为了更好地进行程序的编写，编程语言往往需要引入一些抽象，比如一个函数是一系列操作的封装，一个模块是一堆函数的封装，然后出于通用性的需要，又定义了函数签名来区分具有相同参数类型和参数个数的函数，对于具有相同函数签名的模块，在Erlang我们定义了行为(Behavior)。类似地，Protocol也是一种对数据类型和基于数据类型上实现的一些函数的抽象。在面向对象编程语言(OOP)非常流行的今天，这种抽象更多地被称为类与接口。&lt;/p&gt;
&lt;p&gt;下面简单举例来说明Protocol是什么。在Erlang里面，如果我们要编写一段代码来处理不同的数据类型，往往需要在一大块集中代码里面针对每一种数据类型进行不同的处理。假设我们正在编写一个Json模块，这个模块要处理list, binary, number三种类型的encode(编码)操作，那么就有代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-&lt;span style=&#34;color:#800080&#34;&gt;module&lt;/span&gt;(json)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;encode&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;Item&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;when&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;is_list&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;Item&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;% ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;encode&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;Item&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;when&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;is_binary&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;Item&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;% ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;encode&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;Item&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;when&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;is_number&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;Item&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;% ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果要添加更多的数据类型，那么就在模块内部添加对应那个数据类型的分支。但是如果你没有这个模块的源代码就无法添加，而且经过长时间添加多个类型支持后这个模块变得非常大，难于维护。Elixir引入了Protocol，针对上述的encode操作，可以定义成一个Protocol，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-elixir&#34; data-lang=&#34;elixir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defprotocol&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;JSON&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;def&lt;/span&gt; encode(item)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于任何实现了&lt;code&gt;JSON&lt;/code&gt; Protocol的数据类型对象&lt;code&gt;data&lt;/code&gt;，都可以直接调用下述函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-elixir&#34; data-lang=&#34;elixir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;JSON&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;encode(data)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这些数据类型的&lt;code&gt;JSON&lt;/code&gt; Protocol实现可以分散放在各个文件中，没有要集中维护的问题，当你需要添加一个新的数据类型的支持时，也不需要已有模块的源代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-elixir&#34; data-lang=&#34;elixir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defimpl&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;JSON&lt;/span&gt;, &lt;span style=&#34;color:#990073&#34;&gt;for&lt;/span&gt;: &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;List&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;def&lt;/span&gt; encode(item) &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;# ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defimpl&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;JSON&lt;/span&gt;, &lt;span style=&#34;color:#990073&#34;&gt;for&lt;/span&gt;: &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;BitString&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;def&lt;/span&gt; encode(item) &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;# ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defimpl&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;JSON&lt;/span&gt;, &lt;span style=&#34;color:#990073&#34;&gt;for&lt;/span&gt;: &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Number&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;def&lt;/span&gt; encode(item) &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;# ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过Protocol这样一个抽象，我们可以在函数式的编程语言中，定义对数据类型绑定一系列的接口，然后针对这些通用的接口来进行编程。针对接口编程一个常常被提到的用法是，在需要快速编写原型的时候，使用简单的数据类型进行接口编程，先快速实现功能，等到程序稳定下来，后期需要进行性能优化的时候，再将接口下面的数据类型更换成更高效的实现，这个过程中所有的接口使用代码都不需要修改。&lt;/p&gt;

&lt;h2 id=&#34;elixir中protocol的实现&#34;&gt;Elixir中Protocol的实现&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#elixir%e4%b8%adprotocol%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;Protocol，或者说类接口，它的广义的概念可以追溯到20世纪80年代开始流行的面向对象编程语言，比如C++，甚至更早之前60~70年代就已经存在的Lisp，从那个年代流传至今的很多Lisp方言中，都或多或少有着这种抽象，比如Common Lisp中的Sequence的概念。而在Erlang VM上实现了Protocol的Elixir语言，它则是参考了Clojure的Protocol定义和实现。下面简单描述一下Elixir的Protocol实现。&lt;/p&gt;
&lt;p&gt;从上面的例子我们可以看到，Protocol的本质是将数据类型和接口分开定义，并在运行时进行动态绑定。上述例子中，对于List类型，定义了对应的encode实现，调用Protocol的接口&lt;code&gt;JSON.encode(data)&lt;/code&gt;时，如果data是List类型，就进行动态分发，执行对应的encode实现。那么如何实现这种动态绑定或者说分发呢？由于Erlang是一个函数式编程语言，Erlang VM的基本语义中也只支持模块和函数，因为Protocol的每个实现可以分开，而Erlang VM中基础的编译单元是模块，一个简单的映射方法就是将每个Protocol实现映射为一个模块。而对于接口模块&lt;code&gt;JSON&lt;/code&gt;，很自然地也成为一个单独的模块。那么就只剩下一个问题了，即如何实现当调用&lt;code&gt;JSON.encode()&lt;/code&gt;时，将执行路径转到&lt;code&gt;defimpl JSON, for: List&lt;/code&gt;模块的&lt;code&gt;encode()&lt;/code&gt;函数，这里可以实现为在运行时拼接模块名，然后调用具体模块的函数。上述的Elixir代码中的例子，将编译成对应的Erlang代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          Elixir                                  Erlang
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;defprotocol JSON do                     -module(JSON).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  def encode(item)         生成          encode(item) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;end                                        case item of
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                             data when is_list(data) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                               &amp;#39;JSON.List&amp;#39;:encode(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                             data when is_binary(data) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                               &amp;#39;JSON.BitString&amp;#39;:encode(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                             data when is_number(data) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                               &amp;#39;JSON.Number&amp;#39;:encode(data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                             data when is_struct_X(data) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                               &amp;#39;JSON.X&amp;#39;: encode(data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                           ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的struct_X表示除了几个基本数据类型以外的用户自定义struct类型，其中X为struct的名字，即对应Elixir中的代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-elixir&#34; data-lang=&#34;elixir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defmodule&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;X&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defstruct&lt;/span&gt; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;# ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于各个数据的类型的实现，可以映射为各个Erlang模块：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          Elixir                                         Erlang
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;defimpl JSON, for: List do            生成      -module(&amp;#39;JSON.List&amp;#39;).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  def encode(item) # ...                        encode(item) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;end                                               %% ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;defimpl JSON, for: BitString do                 -module(&amp;#39;JSON.BitString&amp;#39;).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  def encode(item) # ...                        encode(item) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;end                                               %% ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;defimpl JSON, for: Number do                    -module(&amp;#39;JSON.Number&amp;#39;).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  def encode(item) # ...                        encode(item) -&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;end                                               %% ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意其中的模块名是由Protocol名字，即这个例子中的JSON，和具体的数据类型名，即这个例子中的List, BitString, Number等，两者拼接而成。&lt;/p&gt;

&lt;h2 id=&#34;kapok中protocol的实现&#34;&gt;Kapok中Protocol的实现&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#kapok%e4%b8%adprotocol%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;既然Elixir已经实现了Protocol，而且Kapok和Elixir都兼容于Erlang VM，那么除了另外捣腾一套Protocol的用法和实现之外，比较好的做法就是兼容Elixir的实现，从而达到重用所有Elixir己经有的库和代码的效果。Elixir中定义了每个Protocol模块都必需具备的接口函数，具体列出如下，它们都是通过defprocotol宏来实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__protocol__/1&lt;/code&gt;
当参数是&lt;code&gt;:name&lt;/code&gt;，返回Protocol名字
当参数是&lt;code&gt;:functions&lt;/code&gt;，返回一个元素为Protocol接口函数和参数个数的关键字列表
当参数是&lt;code&gt;:impls&lt;/code&gt;，返回一个实现的列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;impl_for/1&lt;/code&gt;
接收一个struct，返回为此struct实现当前Protocol的模块名，如果不存在这样的实现模块则返回&lt;code&gt;:nil&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;impl_for!/1&lt;/code&gt;
类似于上面的&lt;code&gt;impl_for/1&lt;/code&gt;，区别在于当实现模块不存在时不返回&lt;code&gt;:nil&lt;/code&gt;而是抛出异常&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Kapok中，也定义类似的Macro&lt;code&gt;defprotocol&lt;/code&gt;来生成这些接口函数。类似地，对于Elixir中的&lt;code&gt;defstruct&lt;/code&gt;, &lt;code&gt;defimpl&lt;/code&gt; Macro，Kapok也定义了对应的Macro来生成对应的struct结构，和实现函数接口。&lt;/p&gt;
&lt;p&gt;以上所述的种种Protocol结构都是通过Macro，这个强大的Lisp编程方式，来实现的。通过Macro处理手写代码，生成新代码，我们可以在Kapok实现一套类似于Elixir Protocol原语，无缝对接到已有的Elixir代码和库中。&lt;/p&gt;

&lt;h2 id=&#34;kapok的protocol使用示例&#34;&gt;Kapok的Protocol使用示例&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#kapok%e7%9a%84protocol%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;最后附上一个Kapok代码示例，展示一下Protocol在Kapok中的定义和使用，便于理解。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 定义一个用于此示例的Protocol&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defprotocol &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;A protocol to print something.&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 此Protocol唯一接口用来打印某个数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#0086b3&#34;&gt;print &lt;/span&gt;[&lt;span style=&#34;color:#008080&#34;&gt;self&lt;/span&gt;]))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 为Atom数据类型实现pr Protocol&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;defimpl&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;pr &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;Atom&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;io&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defn &lt;/span&gt;&lt;span style=&#34;color:#0086b3&#34;&gt;print &lt;/span&gt;[&lt;span style=&#34;color:#008080&#34;&gt;atom&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;print an atom: #&amp;#39;~p&amp;#39;~n&amp;#34;&lt;/span&gt; [&lt;span style=&#34;color:#008080&#34;&gt;atom&lt;/span&gt;])))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 为List数据类型实现pr Protocol&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;defimpl&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;pr &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;List&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 在print的实现代码中，直接使用了Elixir的Enum Protocol&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 所以这里用了一行代码引入Elixir.Enum模块&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;require&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;Elixir.Enum&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;:as&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;enum&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           &lt;span style=&#34;color:#008080&#34;&gt;io&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defn &lt;/span&gt;&lt;span style=&#34;color:#0086b3&#34;&gt;print &lt;/span&gt;[&lt;span style=&#34;color:#008080&#34;&gt;list&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;print a char list: #\&amp;#34;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 直接在List上调用enum.map，直接使用Elixir库代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;enum.map&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;list&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;fn &lt;/span&gt;[&lt;span style=&#34;color:#008080&#34;&gt;x&lt;/span&gt;] (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;~c&amp;#34;&lt;/span&gt; [&lt;span style=&#34;color:#008080&#34;&gt;x&lt;/span&gt;])))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;\&amp;#34;~n&amp;#34;&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;ns &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;protocol-examples&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;pr&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;defn &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;main&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 下面先后声明了Atom和List两种数据类型的实例，并调用pr.print接口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let &lt;/span&gt;[&lt;span style=&#34;color:#008080&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;abc&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;pr.print&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;data&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let &lt;/span&gt;[&lt;span style=&#34;color:#008080&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;pr.print&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;data&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 得到输出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0086b3&#34;&gt;print &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;an&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;atom&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;abc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0086b3&#34;&gt;print &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;char &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/categories/lisp">Lisp</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/tags/erlang">Erlang</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/elixir">Elixir</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/kapok">Kapok</category>
                                
                            
                        
                    
                
                <guid>https://hhkbp2.com/kapok-the-design-and-implementation-of-protocol/</guid>
                <pubDate>Mon, 19 Mar 2018 14:56:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Kapok 的设计与实现: Macro</title>
                <link>https://hhkbp2.com/kapok-the-design-and-implementation-of-macro/</link>
                
                
                <description>


&lt;figure&gt;
    
        &lt;img src=&#34;https://hhkbp2.com/kapok-the-design-and-implementation-of-macro/kapok_flowers.jpg&#34; title=&#34;木棉花&#34;/&gt; &lt;figcaption&gt;
                
            &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kapok-lang/kapok&#34;&gt;Kapok&lt;/a&gt;是我设计与实现的一个基于Erlang VM的现代Lisp编程语言。&lt;a href=&#34;https://hhkbp2.com/blog/2016/06/08/minds-echo/&#34;&gt;《念念不忘，亦有回响》&lt;/a&gt;这篇文章叙述了这门编程语言的概况。下面我们来聊一聊其中Macro的具体设计和实现。&lt;/p&gt;
&lt;p&gt;Lisp是一系列采用括号包围中缀表达式的列表形式来编写代码的编程语言的统称，借用一位朋友的说法，Lisp就是“裸写AST”。由于这种特别的写法，在Lisp里面将代码作为数据来操作相当容易，而实现这种操作的就是Macro。有很多的书籍和资料都有描述Lisp Macro，这里就不展开了，简单的来说，Lisp Macro是一种在编译时执行的，接受列表输入，输出列表的特殊函数。如果我们构思一下如何在Erlang VM上为一门Lisp语言实现Macro，可以得到这几个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Macro实现为函数，而Erlang和Erlang VM支持函数&lt;/li&gt;
&lt;li&gt;Macro对应的实现函数，其输入是代码AST，输出也是AST&lt;/li&gt;
&lt;li&gt;Macro在编译时执行，Macro本身的代码需要在被调用前的代码编译前编译完成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们进一步看看Kapok Macro的具体实现。&lt;/p&gt;

&lt;h2 id=&#34;函数的实现&#34;&gt;函数的实现&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#%e5%87%bd%e6%95%b0%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;将Lisp Macro实现为函数，首先我们要在Erlang VM上实现Lisp函数。Erlang是一门函数式编程语言，在它的代码编译过程中，生成的Abstract Form(或称为Syntax Tree)和Core Erlang这两种中间代码都直接支持函数。Erlang函数比较特别，参数个数(Arity)也是函数签名的一部分，它支持多个子句但是每个子句只能有固定个数的参数，举例&lt;code&gt;erlang:spawn/1&lt;/code&gt;和&lt;code&gt;erlang:spawn/3&lt;/code&gt;是一个同名函数的两个子句。目前已经存在的几个Erlang VM上的语言实现，如LFE等，大都沿用了Erlang函数的这个设计，除了Elixir在函数参数的最后面引入Keyword List。如果将Kapok的函数直接编译成Erlang函数，函数参数定义和签名可以照抄过来，是容易做到的。但传统的Lisp，比如Common Lisp, 在函数参数定义这块支持&lt;code&gt;&amp;amp;optional&lt;/code&gt;, &lt;code&gt;&amp;amp;rest&lt;/code&gt;, &lt;code&gt;&amp;amp;key&lt;/code&gt;这几个关键字，其中&lt;code&gt;&amp;amp;optional&lt;/code&gt;表示这个关键字后面的参数是可选的，&lt;code&gt;&amp;amp;rest&lt;/code&gt;表示将后面的参数构造成一个list，&lt;code&gt;&amp;amp;key&lt;/code&gt;表示可以用key value匹配的形式来调用函数。能不能在Erlang VM上实现对这几个关键字的支持呢？不妨尝试一下。&lt;/p&gt;
&lt;p&gt;首先思考一下如何实现&lt;code&gt;&amp;amp;optional&lt;/code&gt;，我们知道&lt;code&gt;&amp;amp;optional&lt;/code&gt;后面的参数在调用时可以不传入而采用默认值。举例来说，如果在Common Lisp里面有这个函数定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defun&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;optional&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;c&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 具体实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  )
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下面几种方式来调用都是合法的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种调用的形式可以适配到Erlang的子句上面来。比如上面的函数定义&lt;code&gt;f&lt;/code&gt;可以实现成Erlang函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  f(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, nil, nil).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;B&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  f(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;B&lt;/span&gt;, nil).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;B&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;C&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;%% 具体实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;  ...;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果参数B, C被省略了，那么就用一个默认值来调用参数多一个的子句，这里假定默认参数统一为Atom nil(Lisp里面optional参数的默认值为symbol nil)。&lt;/p&gt;
&lt;p&gt;然后再考虑如何实现&lt;code&gt;&amp;amp;rest&lt;/code&gt;, &lt;code&gt;&amp;amp;key&lt;/code&gt;。我们看看一个常用的函数参数实现技巧。假设现在需要定义一个函数，这个函数只允许有一个参数(不考虑这个限制是否合理)，然而你需要传入两个参数，你会怎么定义这个函数？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;%% An Erlang function which calculates the area of a rectangle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;%% with specified length and width.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;calc_area&lt;/span&gt;({&lt;span style=&#34;color:#0086b3&#34;&gt;length&lt;/span&gt;, width}) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#0086b3&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; width.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你会将这个函数的唯一参数定义成一个能存放两个参数的结构，然后在调用时用实际参数构造一个这样的结构传入。上面是一个以Erlang编写的例子，事实上用其它语言比如Python, C来实现，思路也是一样。&lt;/p&gt;
&lt;p&gt;类似地，对于&lt;code&gt;&amp;amp;rest&lt;/code&gt;参数，可以将&lt;code&gt;&amp;amp;rest&lt;/code&gt;后面的参数构造成一个列表传入。举例说明，若有Lisp的函数定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defun&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;rest&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;b&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 具体实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  )
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以翻译成对应的Erlang函数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  f(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, []).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;B&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ;; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;具体实现，此处&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;B是一个列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果调用Lisp函数&lt;code&gt;f&lt;/code&gt;的实际参数超过一个，那么从第二个参数开始及之后的实际参数都会被放入一个List中，赋值给&lt;code&gt;B&lt;/code&gt;变量。比如对于调用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么实际调用的对应代码就变成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于关键字&lt;code&gt;&amp;amp;key&lt;/code&gt;，也可以采取类似的思路。比如对于函数定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defun&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;key&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;c&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;;; 具体实现 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  )
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会翻译成对应的Erlang函数定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  f(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#555&#34;&gt;maps&lt;/span&gt;:&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;new&lt;/span&gt;()).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;Map&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;%% 具体实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调用时会变换实际参数为第二个形参构造一个Map。比如这样的调用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;:c&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会翻译成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;A&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;Map&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; #{c &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所描述的都是Lisp函数定义里，固定参数后出现&lt;code&gt;&amp;amp;optional&lt;/code&gt;, &lt;code&gt;&amp;amp;rest&lt;/code&gt;, &lt;code&gt;&amp;amp;key&lt;/code&gt;三个关键字其中之一的简单情况。如果两个关键字都用上，还是否能够工作呢？我们知道&lt;code&gt;&amp;amp;rest&lt;/code&gt;, &lt;code&gt;&amp;amp;key&lt;/code&gt;都在最后一个参数上做文章，如果&lt;code&gt;&amp;amp;rest&lt;/code&gt;, &lt;code&gt;&amp;amp;key&lt;/code&gt;同时出现，那最后一个参数是构造成List还是Map？幸好这种情况不会发生，在Common Lisp的编程规范中限制了函数定义中&lt;code&gt;&amp;amp;optional&lt;/code&gt;, &lt;code&gt;&amp;amp;rest&lt;/code&gt;, &lt;code&gt;&amp;amp;key&lt;/code&gt;这几个关键字的用法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;固定参数 + &lt;code&gt;&amp;amp;optional&lt;/code&gt;/&lt;code&gt;&amp;amp;rest&lt;/code&gt;/&lt;code&gt;&amp;amp;key&lt;/code&gt; 其中之一的简单情况，上面我们已经过了一遍&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;key&lt;/code&gt;与&lt;code&gt;&amp;amp;optional&lt;/code&gt;, &lt;code&gt;&amp;amp;rest&lt;/code&gt;混用会产生奇怪行为，所以&lt;code&gt;&amp;amp;key&lt;/code&gt;不能与它们混用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;optional&lt;/code&gt;可与&lt;code&gt;&amp;amp;rest&lt;/code&gt;混用，但是约定&lt;code&gt;&amp;amp;optional&lt;/code&gt;在前，&lt;code&gt;&amp;amp;rest&lt;/code&gt;在后&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有第3点是混用的情况，根据的实现方式可知&lt;code&gt;&amp;amp;optional&lt;/code&gt;和&lt;code&gt;&amp;amp;rest&lt;/code&gt;没有冲突，第3点是可以实现的。&lt;/p&gt;
&lt;p&gt;上面花了很长的篇幅来详细描述如何在Erlang VM实现Lisp函数，由开头的讨论可知Macro也是函数，有了函数的实现作为基础，下面我们进一步讨论Macro函数的输入输出。&lt;/p&gt;

&lt;h2 id=&#34;ast的处理&#34;&gt;AST的处理&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#ast%e7%9a%84%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;从代码的书写形式来看，在Lisp里面代码是列表，因此Lisp Macro的输入和输出都是列表。在实现层面，Lisp列表形式的代码会经过词法分析语法分析，最后变成编译器内部表示AST。AST主要保存这几类信息：类别，数值，元数据。例如，在Lisp代码里面的&lt;code&gt;100&lt;/code&gt;字面量，就需要一个AST数据结构记录下它是一个常量，值为整数100，它在代码文件里面的行号是多少等。Kapok内部将AST定义为Erlang Tuple&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;span style=&#34;color:#008080&#34;&gt;Category&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;Meta&lt;/span&gt;, &lt;span style=&#34;color:#008080&#34;&gt;Value&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中&lt;code&gt;Category&lt;/code&gt;表示这个结点的类别，比如integer常量，list, map等。&lt;code&gt;Meta&lt;/code&gt;是一个保存元数据的Property List。&lt;code&gt;Value&lt;/code&gt;则是记录了实际的取值，比如对于integer常量，就记录了常量的值是100，对于List类型，就记录了这个List包含的所有元素的子结点AST。&lt;/p&gt;
&lt;p&gt;熟悉Elixir元编程的人看到这个定义会觉得很熟悉，因为AST在Elixir中的定义也是如此。&lt;/p&gt;
&lt;p&gt;Macro的输入和输出都是AST，在编译过程中，每一个对Macro的调用，都是使用参数的对应的AST来调用Macro的实现函数。举例说明，比如对于Macro定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defmacro&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;unless&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[test&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;rest&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;body]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Evaluates test. If logical false, evaluates body in an implicit do.&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;case&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;core.true?&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;~test&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     (&lt;span style=&#34;color:#008080&#34;&gt;^true&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;^ok&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     (&lt;span style=&#34;color:#008080&#34;&gt;^false&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;~@body&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有调用代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;unless&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么在Macro展开的时候会得到调用如下，以对应Erlang代码来描述：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;unless&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;AST&lt;/span&gt;{(f &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;)}, [&lt;span style=&#34;color:#008080&#34;&gt;AST&lt;/span&gt;{(g &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;)}, &lt;span style=&#34;color:#008080&#34;&gt;AST&lt;/span&gt;{(h &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;)}])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中&lt;code&gt;AST{X}&lt;/code&gt;表示Lisp表达式&lt;code&gt;X&lt;/code&gt;(也就是在Lisp代码里面看到的形式)对应的AST，每个AST展开都是上面所述的Tuple结构，为方便描述这里使用了简单表示。Macro展开的过程，即是输入的AST流经过unless函数，对应的参数经过变换之后得到输出如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#008080&#34;&gt;AST&lt;/span&gt;{(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;case&lt;/span&gt; (core.true&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;?&lt;/span&gt; (f &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;^&lt;/span&gt;true &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;^&lt;/span&gt;ok)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;^&lt;/span&gt;false (g &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;) (h &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;)))}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;整个输出是一个完整的case表达式的AST，检查case表达式和unless Macro的定义，我们可知&lt;code&gt;AST{(f 1)}&lt;/code&gt;插入到了指定的条件判断参数处，而&lt;code&gt;[AST{(g 2)}, AST{(h 3)}]&lt;/code&gt;中的元素被取出放入了&lt;code&gt;false&lt;/code&gt;分支。&lt;/p&gt;
&lt;p&gt;在Kapok编译的最后阶段，这种内部AST会转换成Erlang Abstract Form，最后把它用Erlang Compiler编译并加载到Erlang VM。这部分的转换的逻辑相当于繁琐，篇幅所限就不再一一展开。&lt;/p&gt;

&lt;h2 id=&#34;macro编译展开&#34;&gt;Macro编译，展开&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#macro%e7%bc%96%e8%af%91%e5%b1%95%e5%bc%80&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;普通函数一般是在运行时执行的，Macro与之不同，它在编译时执行。要在编译时调用一个Macro，这个Macro的定义必须已知，并且经过编译，才可能被调用。在Erlang里面，模块(Module)即是代码的基本组织单元，也是编译的基本单元，虽然也可以对单个表达式进行编译。已有的几种基于Erlang VM的语言，如Elixir, LFE，都采用了将他们的代码模块翻译到Erlang模块然后按模块编译的方式。按模块编译对于Macro的编译和展开会产生一个编译顺序的问题，举例来说在Elixir里面，你需要先声明一个模块&lt;code&gt;m1&lt;/code&gt;，在里面编写宏&lt;code&gt;mac&lt;/code&gt;的定义，然后声明另外一个模块&lt;code&gt;m2&lt;/code&gt;，在&lt;code&gt;m2&lt;/code&gt;里面的代码，假设是函数&lt;code&gt;f&lt;/code&gt;，调用&lt;code&gt;mac&lt;/code&gt;，编译的时候会先编译&lt;code&gt;m1&lt;/code&gt;，使得&lt;code&gt;mac&lt;/code&gt;的定义被编译过，然后编译&lt;code&gt;m2&lt;/code&gt;，编译&lt;code&gt;m2&lt;/code&gt;时在&lt;code&gt;mac&lt;/code&gt;被调用的地方执行它。你不能把&lt;code&gt;f&lt;/code&gt;和&lt;code&gt;mac&lt;/code&gt;都写在同一个模块，否则在这个模块被编译的时候，&lt;code&gt;mac&lt;/code&gt;就不能被执行。在Kapok中，我沿用了Joxa的一个技巧，&lt;code&gt;f&lt;/code&gt;和&lt;code&gt;mac&lt;/code&gt;可以写到同一个模块，但是&lt;code&gt;mac&lt;/code&gt;必须放在&lt;code&gt;f&lt;/code&gt;之前，在编译时，如果发现&lt;code&gt;f&lt;/code&gt;中的代码调用了一个当前模块的Macro，那么就将&lt;code&gt;f&lt;/code&gt;之前的代码当成一个完整的模块，以一个随机生成的模块名，送到Erlang Compiler编译，编译后就可以调用其中的&lt;code&gt;mac&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每次调用一个Macro，都会将调用时的参数AST传入，得到结果AST，再插入到原来调用处，这样称之为一次展开。在Lisp中，Macro的展开是递归的，即是说如果展开&lt;code&gt;mac&lt;/code&gt;之后，得到的代码若还有其它的Macro，比如&lt;code&gt;unless&lt;/code&gt;，还会进一步展开，直至所有Macro都全部展开为止。&lt;/p&gt;

&lt;h2 id=&#34;一个完整的例子&#34;&gt;一个完整的例子&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#%e4%b8%80%e4%b8%aa%e5%ae%8c%e6%95%b4%e7%9a%84%e4%be%8b%e5%ad%90&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;最后，以一个完整的例子来说明整个Kapok编译过程，包括上面提到的函数翻译，Macro的编译和展开等，以帮助理解。用一个简单的Kapok函数定义为例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;defn&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;call g(n = ~p)~n&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码经过词法分析，语法分析阶段后，会生成AST如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{list,[{line,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;}],defn},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;7&lt;/span&gt;}],g},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {literal_list,[{line,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;9&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;}],n}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {list,[{line,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;6&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {binary_string,[{line,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;14&lt;/span&gt;}],&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;call g(n = &lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~p&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {literal_list,[{line,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;34&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;35&lt;/span&gt;}],n}]}]}]}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其结构比较简明，从中可以识别出标识符&lt;code&gt;defn&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;及&lt;code&gt;list&lt;/code&gt;等结构。这个AST由于没有任何Macro调用，经过Macro Expand阶段没有任何变化，然后会转换成Erlang Abstract Form如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{function,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,g,&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; [{clause,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   [{var,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;,n}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   [],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   [{call,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     {remote,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;,{atom,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,io},{atom,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     [{bin,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,[{bin_element,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,{string,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;call g(n = &lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~p&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;},default,default}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      {cons,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,{var,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;,n},{nil,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;}}]}]}]}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段中间代码同样比较简单，容易看到函数&lt;code&gt;g&lt;/code&gt;只带一个参数&lt;code&gt;n&lt;/code&gt;，在它唯一的一个子句里面调用了一个&lt;code&gt;io.format&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;我们可以加上前面提到的Macro，并且添加一个调用Macro的代码，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defmacro&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;unless&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[test&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;rest&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;body]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Evaluates test. If logical false, evaluates body in an implicit do.&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;call unless macro~n&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;case&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;core.true?&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;~test&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     (&lt;span style=&#34;color:#008080&#34;&gt;^true&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;^ok&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     (&lt;span style=&#34;color:#008080&#34;&gt;^false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;before exprs in body!~n&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#008080&#34;&gt;~@body&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;defn&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;n&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#0086b3&#34;&gt;unless&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;1. n: ~p~n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;2. hello macro~n&amp;#34;&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;f&lt;/code&gt;的定义在经过词法与语法分析阶段后得到AST&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{list,[{line,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;}],defn},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;7&lt;/span&gt;}],f},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {literal_list,[{line,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;9&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;}],n}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {list,[{line,&lt;span style=&#34;color:#099&#34;&gt;17&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;17&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;}],g},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;17&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;6&lt;/span&gt;}],n}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {list,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;}],unless},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {list,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;11&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;12&lt;/span&gt;}],&amp;#39;==&amp;#39;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     {identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;15&lt;/span&gt;}],n},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     {number,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;17&lt;/span&gt;}],&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {list,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;8&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     {binary_string,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;}],&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;1. n: &lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~p~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     {literal_list,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;29&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                   [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;30&lt;/span&gt;}],n}]}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {list,[{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;8&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     {binary_string,[{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;2. hello macro&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;}]}]}]}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中可以看到有&lt;code&gt;{list, _, [{identifier, _, unless}, ...]}&lt;/code&gt;这样一个宏调用。因为这个宏是在同一个模块的前面定义的，Kapok编译器就将&lt;code&gt;f&lt;/code&gt;之前的代码，包括&lt;code&gt;g&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;的定义作为另一个模块编译完后，用&lt;code&gt;f&lt;/code&gt;中调用&lt;code&gt;unless&lt;/code&gt;的实际参数AST作为参数来调用&lt;code&gt;unless&lt;/code&gt;。即&lt;code&gt;unless&lt;/code&gt;被调用时得到的参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{list,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;11&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;12&lt;/span&gt;}],&amp;#39;==&amp;#39;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;15&lt;/span&gt;}],n},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {number,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;17&lt;/span&gt;}],&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[{list,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;8&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {binary_string,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;}],&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;1. n: &lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~p~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {literal_list,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;29&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;30&lt;/span&gt;}],n}]}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; {list,[{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;8&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {binary_string,[{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;}],&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;2. hello macro&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;}]}]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中第一个参数是一个list AST，第二个参数是一个List，它的元素也是两个AST。这一串AST流经&lt;code&gt;unless&lt;/code&gt;函数之后，经过转换返回的结果是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   [{line,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;}],&amp;#39;case&amp;#39;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        [{line,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;15&lt;/span&gt;}],{core,&amp;#39;true?&amp;#39;}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         {list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;11&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;12&lt;/span&gt;}],&amp;#39;==&amp;#39;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;15&lt;/span&gt;}],n},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {number,[{line,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;17&lt;/span&gt;}],&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;}]}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        [{line,&lt;span style=&#34;color:#099&#34;&gt;11&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;6&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        [{atom,[{line,&lt;span style=&#34;color:#099&#34;&gt;11&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;7&lt;/span&gt;}],true},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         {atom,[{line,&lt;span style=&#34;color:#099&#34;&gt;11&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;12&lt;/span&gt;}],ok}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        [{line,&lt;span style=&#34;color:#099&#34;&gt;12&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;6&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        [{atom,[{line,&lt;span style=&#34;color:#099&#34;&gt;12&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;7&lt;/span&gt;}],false},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         {list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{line,&lt;span style=&#34;color:#099&#34;&gt;13&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;7&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;13&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {binary_string,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  [{line,&lt;span style=&#34;color:#099&#34;&gt;13&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;18&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;before exprs in body!&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         {list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;8&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {binary_string,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;}],&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;1. n: &lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~p~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {literal_list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  [{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;29&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  [{identifier,[{line,&lt;span style=&#34;color:#099&#34;&gt;19&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;30&lt;/span&gt;}],n}]}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         {list,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             [{dot,[{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;8&lt;/span&gt;}],{io,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              {binary_string,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  [{line,&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;},{column,&lt;span style=&#34;color:#099&#34;&gt;16&lt;/span&gt;}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;2. hello macro&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;~n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;}]}]}]}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从中可以看到输入的AST参数已经被转换插入到指定的地方，这个&lt;code&gt;unless&lt;/code&gt;返回的AST也将被插入到&lt;code&gt;f&lt;/code&gt;中&lt;code&gt;unless&lt;/code&gt;被调用的地方，从而达到修改/变换代码的效果。由于篇幅所限，&lt;code&gt;f&lt;/code&gt;以及整个模块最后生成的Erlang Abstract code就不一一展示了。最后贴出整个示例的完整模块Kapok代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;ns&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;io&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;defn&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;call g(n = ~p)~n&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defmacro&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;unless&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[test&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;rest&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;body]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Evaluates test. If logical false, evaluates body in an implicit do.&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;call unless macro~n&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;case&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;core.true?&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;~test&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     (&lt;span style=&#34;color:#008080&#34;&gt;^true&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;^ok&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     (&lt;span style=&#34;color:#008080&#34;&gt;^false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;before exprs in body!~n&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#008080&#34;&gt;~@body&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;defn&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;n&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#0086b3&#34;&gt;unless&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;1. n: ~p~n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[n]&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#008080&#34;&gt;io.format&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;2. hello macro~n&amp;#34;&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;defn&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#008080&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假定这份代码在文件&lt;code&gt;x.kpk&lt;/code&gt;中，编译安装kapok之后(具体的编译安装过程可以参考Kapok文档，不再详述)使用命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ kapok x.kpk
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即完成编译&lt;code&gt;x&lt;/code&gt;模块，并运行其中的&lt;code&gt;main&lt;/code&gt;函数。可得到结果输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;call unless macro
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;call g(n = 0)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;call g(n = 1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;before exprs in body!
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. n: 1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. hello macro
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在代码里，&lt;code&gt;main&lt;/code&gt;函数调用了2次&lt;code&gt;f&lt;/code&gt;，&lt;code&gt;f&lt;/code&gt;又调用了&lt;code&gt;g&lt;/code&gt;，于是有2行&lt;code&gt;call g(...&lt;/code&gt;的输出。然而由于&lt;code&gt;unless&lt;/code&gt;是在编译时被调用的，只在&lt;code&gt;f&lt;/code&gt;的定义里被调用了一次，所以只能看到1行&amp;quot;call unless macro&amp;quot;的输出，而且&lt;code&gt;unless&lt;/code&gt;展开时输出的这一行在最前面，因为它是在编译阶段执行的，而所有其它&lt;code&gt;io.format&lt;/code&gt;都是在运行阶段执行的。最后我们来看一下最后三行输出，&amp;ldquo;before exprs &amp;hellip;&amp;ldquo;一行是在Macro里面定义的，&amp;ldquo;1. &amp;hellip;&amp;rdquo;, &amp;ldquo;2. &amp;hellip;&amp;ldquo;这两行则是在调用&lt;code&gt;unless&lt;/code&gt;时的输入参数，它们按指定的顺序被组合到同一个&lt;code&gt;case&lt;/code&gt;分支中。&lt;/p&gt;
</description>
                
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/categories/lisp">Lisp</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/tags/erlang">Erlang</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/clojure">Clojure</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/kapok">Kapok</category>
                                
                            
                        
                    
                
                <guid>https://hhkbp2.com/kapok-the-design-and-implementation-of-macro/</guid>
                <pubDate>Mon, 14 Aug 2017 16:20:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>念念不忘，亦有回响</title>
                <link>https://hhkbp2.com/minds-echo/</link>
                
                
                <description>


&lt;figure&gt;
    
        &lt;img src=&#34;https://hhkbp2.com/minds-echo/lights_in_the_grandmaster.jpg&#34; title=&#34;电影《一代宗师》佛前灯&#34;/&gt; &lt;figcaption&gt;
                
            &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;多年以前，当我在Linux下选择Emacs做为编辑器的时候，似乎只是一个比较随机的选择。当时我已经接触并使用VI有一段日子，然而我使用它的体验并不算愉快，也许是我被VI命令模式和编辑模式搞乱了太多次，于是想找个其它编辑器试试，而当时我所知道的Linux终端字符界面编辑器并不多，Emacs是其中一个，然后我就开始使用Emacs，从此一发不可收拾，走上了一条不断修炼的漫漫长路。这段经历后来浓缩成了&lt;a href=&#34;https://hhkbp2.com/blog/2013/01/08/the-pragmatic-emacser/&#34;&gt;《Emacs修炼之道》&lt;/a&gt;这篇文章。Emacs不仅给我提供了一个舒适高效的编辑器工具与环境，也引领我走入了Lisp语言的世界。&lt;/p&gt;
&lt;p&gt;Lisp语言诞生自几十年前，这几十年间世事沧桑，一个又一个浪潮在计算机行业冒升又落下，一门又一门新的编程语言流行而又衰落，Lisp语言早已退出流行的行列，然而却始终吸引着一小群程序员前仆后继地不断进入它的世界。除了传统的几种Lisp方言，2007年出现的Clojure将Lisp在JVM平台重新做了一个现代的实现，也掀起了一波新的潮流，吸引了很多人的关注和使用。几十年前诞生的编程语言，大多早已消失在历史的长河中了，为什么Lisp能够保持长期的生命力呢？正如看待黑客文化时有人主要关注它的政治正确，有人则将它看成是嗡嗡作响的经济引擎，不同的人对Lisp优点的看法也大不相同。有人喜欢Lisp以List作为唯一代码组织方式的简单明了，有人欣赏Lisp由核心几个特殊Form支撑起来的体系，对应着数学领域里面的公理上搭建大厦的体系结构，有人则更实利化只关注可以帮助提高开发效率的那些方面。在我看来，Lisp最吸引我的一点就是强大的元编程能力，非常便于编写DSL。当然这并不是说其它方面不重要，如交互式编程，强调函数式风格但又不强制函数式为唯一风格等特点也是可圈可点。&lt;/p&gt;
&lt;p&gt;Lisp的思想和设计是如此优秀，然而传统的几种方言的实现Scheme，Common Lisp还有另外几个方言都没能紧跟这个时代的步伐，Clojure的作者Rich Hickey必定是深知这点，才会创造了Clojure。感谢Rich，我们得以知道在某个语言的成熟VM上实现一个现代Lisp的可行性，也欣赏到了Clojure设计与哲学的种种优雅美丽之处。Clojure设计于运行在JVM之上，固然是它的成功关键，因为如此一来就可以重用成熟的JVM环境以及丰富的代码库，同时Java程序员这个群体也非常庞大，能吸引到的Clojure使用者也多。另一方面也产生了一些缺点，因为底层的JVM原本是为Java设计实现的，而Java的并发模型还停留在操作系统进程/线程和锁这一种方式，因此Clojure除了保留Java的并发原语之外，还在并发上做了多种尝试，像软事务内存，几种不同的原语delay, future, promise，还有几种不同的引用类型。如此多的新概念和原语不可谓不丰富，同时也是繁多复杂。每当我的脑细胞因为折腾可变与不变或者write skew而被烧死一部分的时候，我总是怀念Erlang Actor并发模型的简单。&lt;/p&gt;
&lt;p&gt;既然要顺适多核化的趋势，就需要语言本身的并发机制支持用户态进程/协程。那么为什么不直接使用Erlang呢？虽然Erlang并不是Lisp，但Erlang的设计也受到Lisp的影响，很多地方都有Lisp的影子，比如交互shell，热更新等。然而我对Erlang也有觉得不满意的地方，除了经常被, ; .几个符号搞晕之外，最大的不满是来自于在Erlang里做元编程的不便，但是Erlang代码又有很强烈的元编程需求，比如OTP里面的大片模板代码。因此在编写Erlang代码的时候，我又相当怀念Lisp的Macro。&lt;/p&gt;
&lt;p&gt;那么，能否把Erlang和Lisp两者的优点结合起来呢，就像在JVM上实现Clojure一样，也许可以在Erlang VM上实现一门Lisp语言？到我的脑海中冒出这个想法的时候，距离我最早接触Erlang已经有三年多时间，距离学习Clojure已经有两年，另外当时在工作上我也写了大半年的Golang，是的，近几年中我学习/使用过的编程语言也不少，基本上每年都会学一到两门新语言，虽然不是每个新学语言都有机会用来写大量的代码，但也算是见识了不少编程语言，也许是对很多好的语言有着更高的期望吧，没有哪种已知的编程语言令我觉得非常满意。带着把Erlang和Lisp结合的想法，我发现原来Erlang VM就像Java VM，VM之上也有中间语言层，可以基于这中间层来实现一门Lisp，而且，早在几年前，就已经有人这样做了。我发现了Robert Virding写的LFE，和Eric Merritt写的Joxa。&lt;/p&gt;
&lt;p&gt;作为参与设计Erlang的元老，Robert一直以来也是探索Erlang应用方面的先行者，早在2007年就写了LFE，并且影响了一众后来基于Erlang VM的新语言，如Elixir。LFE是Lisp Flavored Erlang的缩写，顾名思义，LFE就是把Erlang写成Lisp，除了多了一些括号之外(去掉了Erlang原来的分隔符如, ; .等)跟Erlang十分相似，LFE的设计目标在于提供一个可扩展语法的Erlang，它的实现也达到这个目标。然后跟我理想中的Lisp语言相去有一定距离，我并不喜欢它的Lisp-2风格，跟Erlang相似的模块设计如显式的export，只在编译时可用的Macro等方面。&lt;/p&gt;
&lt;p&gt;另外一个实现Joxa则是由Eric在2011年开始写的，Eric也是Erlang界的老前辈了，他先是试用过LFE，然后觉得并不如意才重新设计和实现了Joxa，之前我写过的文章&lt;a href=&#34;https://hhkbp2.com/blog/2015/08/20/joxa-a-lisp-programming-language-base-on-erlang-vm/&#34;&gt;《Joxa: 一种基于Erlang VM的现代Lisp编程语言》&lt;/a&gt;详细描述了两者的渊源和差别，这里就不再展开了。总的来说，Joxa的Lisp味相对更浓一些，更符合我的个人口味。在过去的一年多时间里，我仔细阅读了Joxa的实现并添加了Erlang R17后引入的Map的语法。Joxa虽好，但有两个主要原因让我不得不考虑重新做一个实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Joxa目前的实现是用自举的方式将Lisp代码经过编译转换成Core Erlang，自举是很cool的一种实现编译器的方式，然而用在语法不够稳定的场景下，会提高后续语言开发的复杂度和难度。Core Erlang也是一个规模小巧设计良好的中间层，然而文档方面相当缺乏，很多时候必需花大量时间人手去获取从上层到它的翻译细节。相对来说更上层的Abstract Format虽然规模更大，然而文档较多，一些工具也只工作在这一层，所以更适合用于做为编译器的目标语言。在这一点上我和Eric讨论得出的一致结论是，要将Joxa用Erlang重写并将目标输出定位到Abstract Format，却因为彼此都忙暂时未有足够精力将其重写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Joxa的设计目标强调它要小而简，希望成为一个小的核心语言，如果其他人有需要就在其上定制扩展。这种设计也是Lisp语言的一种传统特色，由于扩展性强，可以做到核心小扩展大，类似的思想也被人在不同的语言和项目上实现，比如PyPy和Python 3。然而我更希望有一套功能较多较全的编程语言，因此需要在语法和代码规模上都需要添加(或者改动，但主要是添加)很多内容，这就与Joxa的目标有冲突。据我所知Eric对Joxa有明确的定位，应该不会乐意在Joxa里面接受这些添加或改变，因此最好我还是用一个新项目名字来重写一个基于Erlang VM的Lisp实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一直以来我有个朦胧的想法，希望在下一个我能够自己决定命名的项目，能够用上一个带有我居住所在地中国华南地区的风物，或者带有东南亚色彩的名字，在给这个新项目取名时，老家旧居楼房前面的两棵高大的木棉树出现在我的脑海，那是一种在南方非常常见非常普通的树，平时不会特别觉察到它们的存在，然而有时觉察到它们的存在却又不禁觉得特别，像鲁迅笔下所说：“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树”。于是就将这个新项目的名字取为木棉，英文是Kapok。&lt;/p&gt;
&lt;p&gt;我想，Kapok这个新的基于Erlang VM上的Lisp实现会包含如下这些内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一套类似Clojure风格的现代Lisp语法(Lisp-1)，当然在语法上并不能无脑照抄Clojure，比如方括号[]在Clojure中表示Vector，在Erlang却是List，那么Kapok里如何选择？若语义跟随前者，是用Erlang的tuple来实现Vector语义还是另外再做一套实现？若语义跟随后者，和普通圆括号()又如何区分，各自的使用场景如何确定？每处细节都需要仔细考量，这些细节也会影响其它方面，如下面将提到的兼容性。另外Clojure语法糖较多，而我不喜欢太甜。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与Erlang VM保持最大的兼容，在Erlang VM上实现的多种语言，都选择了将语法及语义尽量向Erlang靠拢，比如新语言的函数直接编译成Erlang的函数，如此得以保持良好的兼容性，新语言的代码可以直接与Erlang VM基础设施与已有库代码进行相互调用，不像Clojure那样需要通过中间包装。Erlang是一门函数式语言，这意味着新语言最好也保持这种函数式的语义，当然也可以通过上层逻辑修改这种限制，比如另一门基于Erlang VM的语言Elixir通过在编译器做变量名映射的技巧使得在Elixir里同一个变量可以做多次绑定，如此一来Elixir在变量使用上更像命令式语言。基于两个原因我个人更偏向于在Kapok里面完全保留Erlang的函数式语义，一是它利于并发，二是它语义更清晰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新的语言机制，目前已经在考虑中的有：支持Clojure的Protocol(运行时类型分派，让语言更动态)，探索一套带类型标注的DSL来做强类型编程(强制编译时类型检查，让语言更静态)，Lazy API。其中第Protocal和Lazy API源自Clojure(当然Clojure也借鉴了其它语言)，并且已经在Elixir中得到实现。同时我对其它新想法持开放的态度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能丰富接口现代的标准库，包括常用宏，文件，网络等方面，特别一提的是Erlang原生用字符列表来表示字符串并不理想，因此需要有一整套高效易用的unicode字符串标准库，在LFE和Elixir中都重新定义了binary string，这是一个比较好的方案，可以借鉴。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强大且现代的开发工具集，包括：文档及Apropos接口/工具，编辑器集成(如Emacs mode), 项目管理工具(参考Mix)，交互性开发环境(集成Slime和Swank)等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的几点综合了Clojure, Erlang, Joxa, LFE, Elixir, Emacs等多种语言或机制，希望可以取多家之长，提供一套强大完整的开发环境。当然也可以说是一个大杂烩，然而不是无脑照搬，库和工具集可以丰富多样，然而基础语法需要保持简约节制，避免出现C++或Scala那样过于烧脑的设计。同时也要了解到上面几点内容只是一个初步的想法，后面可能会根据实际情况有所添加或改变。我一直有个用一门新编程语言编写一个开源数据库的朦胧想法，Kapok完善到一定程度之后，也许可以用Kapok来完成我这个想法。&lt;/p&gt;
&lt;p&gt;有了简要设计，就可以开工编写代码了，首先要实现的是1, 2两点，亦即核心编译器部分。要写Kapok的想法早在去年就已经产生，然而一直拖拖拉拉未能动手。去年年中祖母去世，让我明白到时间匆匆人生太短，有些事情想做就抓紧时间去做，迟早人生的终点只是青山上的一把黄土。于是开始动手，由于平时上下班剩余时间不多，生活琐事缠身，进展较为缓慢，拖拉了几个月逐渐完成了编译器前端，大概到今年初开始写后端，也算是慢慢重温了一遍大学时开的编译课程。最近有了一些时间，终于折腾到可以跑起来的程度。我想Kapok这个项目不可谓不大，终究不能短期内完成，要做到非常完善的程度，更是有待时日。就像长跑，并非重在一时之快慢，积跬步恒坚持，方能走得更久更远。我所需要做的，就是调整呼吸，跨开步子。&lt;/p&gt;
&lt;p&gt;于是就把Kapok开源了，github地址在&lt;a href=&#34;https://github.com/kapok-lang/kapok&#34;&gt;这里&lt;/a&gt;，虽然暂时还有很多问题和缺点，也有很多想法未能实现，但我想这也算是一个不错的长跑起步。&lt;/p&gt;
&lt;p&gt;十年之前，当我第一次安装并启动Emacs的时候，决没有料到会十年之后它带领我在Lisp的世界走了这么远。几年之前在接触Erlang，Clojure的时候，没有想到有一天会用Erlang重写一门Clojure风格的Lisp语言。一年之前开始着手Kapok的时候，我也不知道这个项目要做到何时，做到什么程度。然后事情冥冥中就这样发生了，而我将沿着这条路继续向前走。王家卫电影《一代宗师》里面，宫先生说“念念不忘，必有回响”，行知做人跟练武一样，秉着意念坚持下去，终究能有一点回响。&lt;/p&gt;
</description>
                
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/categories/lisp">Lisp</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/tags/erlang">Erlang</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/clojure">Clojure</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/kapok">Kapok</category>
                                
                            
                        
                    
                
                <guid>https://hhkbp2.com/minds-echo/</guid>
                <pubDate>Wed, 08 Jun 2016 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Joxa: 一种基于 Erlang VM 的现代 Lisp 编程语言</title>
                <link>https://hhkbp2.com/joxa-a-lisp-programming-language-base-on-erlang-vm/</link>
                
                
                <description>&lt;p&gt;&lt;a href=&#34;http://joxa.org/&#34;&gt;Joxa&lt;/a&gt;是一种基于Erlang VM的现代Lisp编程语言，创始人是美国的Eric Merritt&lt;a href=&#34;#1&#34;&gt;[1]&lt;/a&gt;。通过在Erlang VM上引入一个精心设计的Lisp语法，它保留了Lisp和Erlang两者的众多优点：简洁而且语义清晰的Lisp语法，强大的Macro，鼓励交互式开发，支持高并发，函数式风格等，并且与现有的Erlang平台保持良好兼容。它是一门功能全面的通用编程语言。&lt;/p&gt;
&lt;p&gt;Joxa的官方网站是&lt;a href=&#34;http://joxa.org/&#34;&gt;joxa.org&lt;/a&gt;，在这个官方网站上，有它的源代码&lt;a href=&#34;https://github.com/joxa/joxa&#34;&gt;github地址&lt;/a&gt;，以及&lt;a href=&#34;http://docs.joxa.org/en/latest/&#34;&gt;在线文档&lt;/a&gt;。为什么这门编程语言取名为Joxa呢？关于Joxa这个名字的由来，Eric Merritt曾经对我在邮件组的提问做过如下解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实这个名字并无特别的意义。很多年前我想开始一个“基于Java的某个项目”，于是有了它的缩写Joxa这个名字。这个项目从来没有开始做过，但我把域名买下来了并一直持有着。到今天，4个字母的域名已经很少能注册到了，所以我决定用它来做为这门语言的名字。&lt;a href=&#34;#2&#34;&gt;[2]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了名字开头有个字母&amp;quot;J&amp;quot;，Joxa与Java并没有太大的关系了，Joxa主要受到了Erlang及基于JVM的编程语言Clojure的影响。下面我们先介绍一下Erlang和Clojure，再讨论Joxa受到了它们的哪些影响。&lt;/p&gt;

&lt;h2 id=&#34;1-erlang-clojure以及joxa&#34;&gt;1. Erlang, Clojure以及Joxa&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#1-erlang-clojure%e4%bb%a5%e5%8f%8ajoxa&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;



&lt;h3 id=&#34;11-erlang高并发的函数式容错编程语言&#34;&gt;1.1 Erlang，高并发的函数式容错编程语言&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#11-erlang%e9%ab%98%e5%b9%b6%e5%8f%91%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8f%e5%ae%b9%e9%94%99%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;Erlang是一门通用的并发程序设计语言，它由瑞典爱立信的Joe Armstrong在上世纪80年代开发，并于1998年对外开源，Erlang这个名字来源自丹麦数学家及统计学家Agner Krarup Erlang。经过近30年的发展，Erlang目前是支持高并发的编程语言翘楚之一，它在语言层面封装了Actor模型，实现了用户空间的轻量级进程，将消息传递作为Actor间通信的唯一方式，避免了由传统的线程和锁在并发方面的限制与缺点。Erlang被设计为电信级系统的编程语言，强调分布式，容错，软实时和公平调度，在语法上它主要受到Prolog及Lisp的影响，保留了函数式，动态，交互式开发等特点。具体来讲，Erlang这个名字可以分成3个方面的要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编程语言Erlang本身&lt;/li&gt;
&lt;li&gt;总称为OTP的一系列程序设计原则及代码库&lt;/li&gt;
&lt;li&gt;称为Erlang VM或BEAM的Erlang虚拟机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Erlang设计于近30年前，因此从现在的角度来看，它在语法，编程环境(包括文档等)及工具链等方面有很多地方都有改进空间。由于Erlang VM是目前工业界支持高并发的最成熟的VM之一，大量技术专家及工程师们在上面投入了无数的工作，通过在Erlang VM上设计一门新语言来重用Erlang VM的优良特性，既能发挥Erlang VM的长处，又能改善Erlang语言本身在语法、工具链等方面的缺点，扬长而避短，是比较完美的方案。业界近几年涌现了众多基于Erlang VM的编程语言，下面介绍其中几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LFE&lt;br&gt;
&lt;a href=&#34;http://lfe.io/&#34;&gt;LFE&lt;/a&gt;是Lisp Flavored Erlang的缩写，它是由Robert Virding&lt;a href=&#34;#3&#34;&gt;[3]&lt;/a&gt;于2007年开始开发的一门函数式的并发的通用编程语言，LFE采用了Lisp-2&lt;a href=&#34;#4&#34;&gt;[4]&lt;/a&gt;风格的语法，通过将LFE代码编译为Core Erlang代码运行在BEAM上，保留了Erlang VM分布式，容错，软实时等优点，同时支持Lisp Macro，使得LFE兼有强大的元编程能力，并实现了一个功能丰富的REPL&lt;a href=&#34;#5&#34;&gt;[5]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Reia&lt;br&gt;
&lt;a href=&#34;http://reia-lang.org/&#34;&gt;Reia&lt;/a&gt;是一门基于Erlang VM上的类似Ruby的脚本编程语言，它由Tony Arcieri&lt;a href=&#34;#6&#34;&gt;[6]&lt;/a&gt;于2010年中开始开发，它在Erlang VM的分布式，并发，容错，热更新的基础之上，引入了Ruby的友好语法，灵活的代码块，反射及元编程功能力。遗憾的是，Reia在2011年宣布不再更新。&lt;/li&gt;
&lt;li&gt;Elixir&lt;br&gt;
&lt;a href=&#34;http://elixir-lang.org/&#34;&gt;Elixir&lt;/a&gt;是一门动态的函数式编程语言，它由José Valim&lt;a href=&#34;#7&#34;&gt;[7]&lt;/a&gt;于2012年开发。Elixir同样采用了类Ruby的语法，通过支持强大的Macro功能，它在简洁的语言核心上，建立了一系列的标准库，包括Unicode字符串及相关操作，重写了单元测试框架，丰富的数据类型等，它吸收了Clojure的Protocol，严格和惰性API，还提供了现代的交互命令行，脚本相关的库函数及项目管理工具。通过将Elixir代码编译为Erlang AST，Elixir得以重用Erlang VM的高并发及高效率，克服了Ruby在并发方面的缺陷。由于得到Jose及其它Ruby界牛人的喜爱及宣传&lt;a href=&#34;#8&#34;&gt;[8]&lt;/a&gt;，Elixir在近两年开始流行起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于本文主要是讲Joxa，上述这几种编程语言只是简单带过，就不详细展开了。&lt;/p&gt;
&lt;p&gt;上面几种编程语言的设计方案虽然有很多不同之处，但从整体思路上几乎是相同的，那就是：通过将代码编译成为Erlang VM上的代码，良好兼容Erlang VM，于是保留了上述3要素中的后两点，同时从头设计语言的语法，并在标准库，工具链等一些方面做补充完善。Joxa的设计也是类似，它选择了Lisp做为Erlang VM上的新语言，不过它走了一条和LFE不同的道路。Eric Merritt后来专门写了一个博客文章&lt;a href=&#34;http://blog.ericbmerritt.com/2012/02/21/differences-between-joxa-and-lfe.html&#34;&gt;《Differences Between Joxa and LFE》&lt;/a&gt;来谈Joxa和LFE的不同之处，他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最主要和重要的区别在于这两门语言的目标。我认为Robert实现LFE的主要目标在于提供一个可变的语法可扩展的Erlang版本，如此一来人们就可以在需要时改变语言。同时我坚信Robert喜欢实现编程语言，他应该很享受实现LFE的过程。我当然也乐于实现Joxa，然而，当坐下来实现Joxa的时候我怀有一些非常特定的目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我需要一个用于开发DSL(Domain Specific Language，领域特定语言)的平台&lt;/li&gt;
&lt;li&gt;我想要一个更具交互性和动态的开发环境。类似于Slime和Swank那种&lt;a href=&#34;#9&#34;&gt;[9]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我希望充分利用所有已经存在的相当优秀的Lisp工具&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述每点都可以在Erlang里面解决。例如，我可以用Leex和Yecc&lt;a href=&#34;#10&#34;&gt;[10]&lt;/a&gt;实现DSL，但我实现DSL的最好体验总是来自Lisp：使用Lisp函数和Macro来打造这些DSL。不过我使用Erlang有很长时间了，我不愿意放弃Erlang VM上面的优良功能来换成Lisp的种种优点。唯一的解决方法似乎只有使用一门基于Erlang VM之上的Lisp语言。&lt;/p&gt;
&lt;p&gt;显而易见的首先选择是LFE，于是我花了几周时间深入研究这门语言和它的内部实现。最后我得到这个结论：它并没有满足我的需求。剩下的唯一退路就是我自己重新创造一门语言(同时也有一点怀疑自己不太明智)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从整体来看，LFE更像一门披着Lisp外衣的Erlang，相当于给原来Erlang语法添加了括号和Macro，这与Eric Merritt理想中的Erlang VM上的Lisp语言相去甚远，于是他创造了Joxa，而Joxa的语法及风格受到Clojure的影响更大。为什么Clojure能受到Eric的如此青睐呢？它到底有什么出众之处呢？下面我们来了解一下。&lt;/p&gt;

&lt;h3 id=&#34;12-clojurejvm上的函数式lisp编程语言&#34;&gt;1.2 Clojure，JVM上的函数式Lisp编程语言&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#12-clojurejvm%e4%b8%8a%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8flisp%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;Clojure是一门动态的强类型编程语言，作者是Rich Hickey。它寄居在JVM之上，设计成能够与JVM/Java良好互操作，既利用了JVM所提供的成熟高效的运行环境，也兼容众多流行的Java库与框架，同时它采用了Lisp语法和Macro，非常便于表达DSL，加上一套函数式的持久数据结构，并提供并发机制及惰性语义，使得简洁优雅语言成为函数式编程，并发编程的良好载体，同时重用了成熟流行的JVM平台，使得它便于在现有Java程序员中推广并流行，在这一点上区别于以往所有独立开发的函数式语言。此外它也吸收了Java中的面向对象思想和CLOS&lt;a href=&#34;#11&#34;&gt;[11]&lt;/a&gt;，发展出Protocol及多重方法。另外，Clojure自带一系列丰富的标准库，定义了一套项目管理规范，并提供了优秀的项目工具及REPL，使得它在开发环境，交互式开发方面成为佼佼者。&lt;/p&gt;
&lt;p&gt;Clojure设计成为Java的一个库包，Clojure代码会编译成JVM byte code，正因为它以一种非侵入性的方式运行在JVM之上，所以在函数式的语言层面，会有一些其它函数式语言不可能出现的“瑕疵”，例如函数没有尾递归优化。兼容JVM平台的已有代码，在重用/连接已有项目方面既是一种优势，但有时混合函数式与命令式代码也会产生实际冲突。在并发方面，语言提供的多种并发原语，delay, future, promise，agent，STM等虽然强大，但从语言整体来看比较复杂。Clojure的很多地方可以体会到作者有意保持简单与功能(复杂)的平衡，在设计上做了务实折衷的克制。与此相反，另外一个基于JVM的语言Scala在设计上就显得博爱放任，看到各个好的特性就收入到语言当中，宛如中国古代的皇帝举国征选妃嫔。&lt;/p&gt;
&lt;p&gt;相比各种“主流”编程语言，Clojure至今仍是小众语言，虽然如此，它的推出仍然不可谓不成功，既培养了一个健康壮大的社区，也在市场上占有一定的流行度，产生了一批具有相当影响力的项目，如流式数据处理框架&lt;a href=&#34;https://storm.apache.org/&#34;&gt;Storm&lt;/a&gt;等。Clojure成功地向人们展示了这几个可能性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在JVM平台实现一个函数式，并发的动态编程语言&lt;/li&gt;
&lt;li&gt;通过融合持久数据结构，Protocol等优异特性，复兴Lisp&lt;/li&gt;
&lt;li&gt;如何语言设计上在功能、简单与务实之间取得折衷平衡并树立起自身的特色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正因为有些如此之多的优点，Clojure才对程序员们有着如此之大的吸引力。也难怪身为老Lisp爱好者的Eric Merritt在创造Joxa时会受到Clojure的较大的影响。下面我们来谈谈Joxa的设计。&lt;/p&gt;

&lt;h3 id=&#34;13-joxa-erlang-vm上的新lisp编程语言&#34;&gt;1.3 Joxa, Erlang VM上的新Lisp编程语言&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#13-joxa-erlang-vm%e4%b8%8a%e7%9a%84%e6%96%b0lisp%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;对照上述多种语言的实现，Joxa的设计主要有如下几个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上层语言为Lisp，主要目标为用于写DSL(或者作为其它上层Lisp的元语言)，语言的核心部分要简洁&lt;/li&gt;
&lt;li&gt;底层将Joxa代码编译成Erlang VM代码，将Joxa代码映射到Erlang上的对应语法结构，比如Joxa里面的函数即为Erlang函数&lt;/li&gt;
&lt;li&gt;语言核心之外提供REPL，方便编译/执行脚本的命令行工具等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中Lisp的语法可以参考简洁，优雅的Clojure，由于Erlang VM与JVM有着非常多的差异，正如Erlang语言与Java语言有着非常多的差异，所以可以预期的是，Joxa在语法上面不能完全保持与Clojure一致，同时这里面有一个目标用户的问题：Joxa更多的是为了Clojure程序员转向Erlang平台而设计，还是为了Erlang程序员转向Lisp而设计。若为前者，就尽量保留可能多的Clojure语法及规范，若为后者则将语法尽可能向Erlang靠拢比较理想。这时Joxa选择了后一种，即认为Joxa主要是解决Erlang现有的问题，所以从语法上来考虑，最后出来的结果很可能是一种Lisp与Erlang的独一无二的新结合。所有的Lisp语言从结构上来看，都具有一种类似数学的体系结构，包括以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一切表达式皆为List，List有两种，原子及函数调用。代码即数据(总结为同像性)&lt;/li&gt;
&lt;li&gt;7个基本原语(又称之为特殊Form)加上可以操纵语言本身的Macro，两者作为核心，在此之上演化出整个语言&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就像数学体系，最核心的部分是几条基本原理，然后通过逻辑推导，演化出其它数学分支以构成整个体系，可以不断向外扩展。Joxa将会有同样的结构，核心部分将保持尽可能的简洁，只包括基本原语及Macro，极简的核心既节省开发成本，也给外延留下尽可能大的空间。此处的外延包括针对特定问题领域而言的DSL，也包括其它上层的Lisp语言，从本质上来说这两者本来就没有区别，只不过因为针对的范围有大有小所以说法不同。从语法设计上，Joxa会跟LFE有如下的不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Joxa会是Lisp-1，而LFE是Lisp-2&lt;/li&gt;
&lt;li&gt;Joxa的语法会向Lisp靠拢，而LFE更像Erlang&lt;/li&gt;
&lt;li&gt;Joxa中Macro求值语义与Lisp更为一致，而LFE的Macro求值语义与函数求值语言不同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了保持与Erlang VM现有的平台等保持无缝兼容，以充分利用现有的Erlang VM的开发规范与代码库等，第2点是必需的。将Joxa建立在Erlang VM平台的生态环境之上，固然是因为作者对Erlang VM的熟悉与喜欢，客观上也可以充分发挥Erlang生态的优势。从上面的叙述也可以看到，众多Erlang VM上的非Erlang编程语言也采用了这种“无缝兼容”设计，虽然它们在实现层面会有一些不同之处。这一点同时确定了Joxa将会保留Erlang的一些语言特性，例如按文件划分的模块化，函数式风格，代码要求先通过编译等。&lt;/p&gt;
&lt;p&gt;第3点与开发环境相关，REPL是各种Lisp方言已经是司空见惯了，Erlang在设计的时候也吸收了这个概念，但是实现得不如Lisp的REPL那么好用，比如强制输入为表达式(每行的后面必须输入&amp;quot;.&amp;ldquo;号)，Record不能用等。Joxa的REPL会参考Clojure与Erlang的REPL，结合前者的完整性和后者的功能，在易用性给予特别的关注。同时针对编译、脚本化等开发流程中的各个阶段都提供编辑器、命令行工具等支持。&lt;/p&gt;

&lt;h2 id=&#34;2-设计与实现细节&#34;&gt;2. 设计与实现细节&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#2-%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;下面我们来详细讨论Joxa的设计与实现。根据上述的设计要点，要将Joxa代码要编译成Erlang VM代码，必需先熟悉Erlang代码的编译过程，在此过程中找出合适的切入点。&lt;/p&gt;

&lt;h3 id=&#34;21-erlang编译过程&#34;&gt;2.1 Erlang编译过程&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#21-erlang%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;一个经典的编译过程可以分为如下图所示的多个阶段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;classic_compilation.png&#34; alt=&#34;传统编译过程的各阶段&#34;&gt;&lt;/p&gt;
&lt;p&gt;图1 经典编译过程的各阶段&lt;a href=&#34;#12&#34;&gt;[12]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经典的编译过程可以分为词法分析，语法分析，语义分析，中间代码生成，中间代码优化，机器码生成等多个阶段。Erlang的代码编译过程跟经典的编译过程基本一致，也可以分成类似的多个阶段，各个阶段的输入输出如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;erlang_compilation.png&#34; alt=&#34;Erlang编译过程的各阶段&#34;&gt;&lt;/p&gt;
&lt;p&gt;图2 Erlang编译过程各阶段的输入输出&lt;/p&gt;
&lt;p&gt;其中Core Erlang为于Erlang代码与VM内部中间代码之间的一层，它是在1999年前后提出的一种BEAM(Erlang VM的最新实现)上的语言，它被设计为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法清晰简单，严格的更高阶函数式语言&lt;/li&gt;
&lt;li&gt;尽可能规范化，以便相关代码遍历工具的开发&lt;/li&gt;
&lt;li&gt;从Erlang代码向Core Erlang代码的翻译应该直白，从Core Erlang向VM内部实现中间代码的翻译也应该简单&lt;/li&gt;
&lt;li&gt;有良好定义的文本表示形式，语法简单无歧义，便于人阅读，调试及测试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于Core Erlang是清晰简单，有良好定义的文本语言，便于作为目标语言，而且Erlang的代码优化和错误检测大多都在Core Erlang层进行，如果我们要在Erlang VM打造新编程语言，那么将新语言的代码编译成Core Erlang(或AST)，将会是一个很好的解决方案。很多Erlang VM上的语言都选择了这种方案，比如LFE，但也有语言选择了编译成Erlang AST，比如Elixir，精通Elixir Macro的人对Erlang AST应该比较熟悉。相对于Core Erlang，Erlang AST更接近于Erlang本身，层次也更高。Core Erlang相关的功能定义在&lt;code&gt;cerl.erl&lt;/code&gt;这个模块里面，包括对如模块、函数等各种Erlang语言结构的初始化、操纵等功能的一系列函数。&lt;/p&gt;

&lt;h3 id=&#34;22--一个简单例子&#34;&gt;2.2  一个简单例子&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#22--%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e4%be%8b%e5%ad%90&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;下面举一个简单的Hello World程序作为例子&lt;a href=&#34;#13&#34;&gt;[13]&lt;/a&gt;，让读者对Erlang AST与Core Erlang有一个感性认识。原始的Erlang代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-&lt;span style=&#34;color:#800080&#34;&gt;module&lt;/span&gt;(test).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-&lt;span style=&#34;color:#800080&#34;&gt;export&lt;/span&gt;([hello_world&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;]).
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;hello_world&lt;/span&gt;() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#555&#34;&gt;io&lt;/span&gt;:&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;format&lt;/span&gt;(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;).
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对应的Core Erlang代码如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;module &amp;#39;test&amp;#39; [&amp;#39;hello_world&amp;#39;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    attributes []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;#39;hello_world&amp;#39;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;fun&lt;/span&gt; () &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        call &lt;span style=&#34;color:#555&#34;&gt;&amp;#39;io&amp;#39;&lt;/span&gt;:&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;&amp;#39;format&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            (&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;“&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;Hello&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;World&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;”&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比两份代码，可以看到Core Erlang与Erlang之间的映射还是很直观的。将原始的Erlang代码编译为Erlang AST，可以得到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[{attribute,&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;,module,test},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; {attribute,&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;,export,[{hello_world,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;}]},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; {function,&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;,hello_world,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   [{clause,&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;,[],[],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     [{call,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {remote,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,{atom,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,io},{atom,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,format}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         [{string,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;}]}]}]}]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译为Core Erlang AST即得到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{c_module,[],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  {c_literal,[],test},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [{c_var,[],{hello_world,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;}}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      [],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     [{ {c_var,[],{hello_world,&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;}},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {c_fun,[&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;,{file,[]}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         [],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         {c_call,[&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,{file,[]}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           {c_literal,[&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,{file,[]}],io},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           {c_literal,[&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,{file,[]}],format},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           [{c_literal,[&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,{file,[]}],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;}]}}}]}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比两者，容易看出Erlang AST更高层更抽象，Core Erlang AST更底层更规范。&lt;/p&gt;

&lt;h3 id=&#34;23-编译器&#34;&gt;2.3 编译器&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#23-%e7%bc%96%e8%af%91%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;下面我们继续来讨论Joxa的编译过程，由于Core Erlang(及AST)可以由Erlang编译器编译成最终的机器码，我们只需将Joxa代码编译成Core Erlang AST便可实现将Joxa编译成机器码整个编译过程，从编译领域的分类来看，目标生成的代码是Core Erlang AST，操纵Core Erlang AST可以直接调用&lt;code&gt;cerl.erl&lt;/code&gt;的接口函数，因此编译器后端这一块相对是比较简单的，重点在于前端部分：即将Joxa代码编译成Core Erlang AST。由于Joxa是Lisp语法，Lisp代码以括号划分边界的代码树的方式来表示，本身就已经有良好的结构，所以前端部分也比较简单。区别于LFE或Elixir用Leex或Yecc来生成LALR&lt;a href=&#34;#14&#34;&gt;[14]&lt;/a&gt;式Lexer与Parser，Joxa采用了手写PEG&lt;a href=&#34;#15&#34;&gt;[15]&lt;/a&gt; Lexer和Parser的方式。PEG编译器的代码量较小，Joxa编译器是在Erlang PEG生成器&lt;a href=&#34;https://github.com/seancribbs/neotoma&#34;&gt;Neotoma&lt;/a&gt;生成代码的基础上写成的。(本节涉及到很多编译领域的术语或技术，由于本文主要是介绍Joxa，篇幅所限故不会详细解释这些术语或技术，有兴趣的读者可以自行寻找相关的资料做进一步了解)&lt;/p&gt;
&lt;p&gt;特别值得一提的是，Joxa的编译过程是自举的，即Joxa编译器本身是由Joxa代码编写的，这与LFE或Elixir的编译器用Erlang编写不同。Joxa的自举要求先有一份以Core Erlang AST格式存在的具有正常编译功能的代码，这部分代码在Joxa的Github代码库中，相对根目录的路径是&lt;code&gt;src/ast&lt;/code&gt;(后面给出所有的代码路径都相对于根目录)。通过用Erlang编译器将这份AST代码编译成BEAM代码，然后就得到一个能直接在BEAM上执行的Joxa编译器，然后就可以运行此编译器，将编译器的Joxa源代码编译成Core Erlang AST格式。整个流程和依赖如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;joxa_self_bootstrap.png&#34; alt=&#34;Joxa的自举及编译流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;图3 Joxa的自举及编译流程&lt;/p&gt;
&lt;p&gt;由上图可以看到整个流程三个步骤是一个循环，要成功实现自举，必然要先实现其中的一个部分，在此基础上才能实现其中其它两个部分。在Joxa的编译器实现中，AST这部分先由作者Eric人手先写出基本的语法解析功能，然后再编写对应功能的编译器的Joxa代码，用AST编译出来可执行的编译器，去验证对应的Joxa代码，然后再按此流程不断添加更多的功能，错误一般出现在编译Joxa代码的时候，此时遇到的错误是由新添加的AST代码还是Joxa代码引起的，有时并不容易定位出来。虽然Core Erlang简单清晰，但手写Core Erlang AST是相当繁琐的，而且由于Joxa语法本身还在不断演变，从头开发一个这样的自举编译器，其难度可以猜想是比较大的。我曾经为Joxa添加过Map语法的支持，对此开发流程的复杂性有较深的体会。编程语言的自举也可以按另外一个思路来做：先用另外一门常见的语言，比如C语言来写编译器，然后当语言的语法发展到比较稳定成熟的时候，再使用这门语言的本身来实现自身的编译器，由于已经有了一个能够工作经过充分检验的C编译器，所以自举的实现就有了一个可靠的保障，大大降低其难度。&lt;/p&gt;
&lt;p&gt;编译器这部分的Joxa代码的路径是&lt;code&gt;src/joxa-cmp-*.jxa&lt;/code&gt;(其中&lt;code&gt;*&lt;/code&gt;符号表示通配)。按照编译器前端和后端的分类法，下面我们讨论一下各主要文件的代码分布。PEG的词法分析部分需要构造一系列对应于词素(lexeme)的正则表达式，首先需要有正则表达式的元操作的函数定义，所谓“元操作”，用各种编程语言里面的正则表达式的术语来说，即是元字符，比如&amp;rdquo;*&amp;ldquo;符号用于“匹配0个或多个”。在PEG里面元操作是通过函数来表达的，这部分的代码在&lt;code&gt;src/joxa-cmp-peg.jxa&lt;/code&gt;。词素，比如注释或数字，它们的定义放在&lt;code&gt;src/joxa-cmp-lexer.jxa&lt;/code&gt;。&lt;code&gt;src/joxa-cmp-parser.jxa&lt;/code&gt;则包含Parser的代码。编译器的主要逻辑放在&lt;code&gt;src/joxa-compiler.jxa&lt;/code&gt;，它调用Parser来解析读入的字符流，成功解析之后调用&lt;code&gt;make-forms&lt;/code&gt;函数递归遍历解析得到的语法树来生成Core Erlang AST，在编译过程中会执行对函数调用的合法性检查，Macro的递归展开等动作。后端的代码按语义的分类分成下述多个文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-binary.jxa           # Binary
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-call.jxa             # 函数调用
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-case.jxa             # case语句
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-defs.jxa             # 函数、宏定义
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-expr.jxa             # 表达式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-joxa-info.jxa        # 模块info
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-literal.jxa          # 常量，常量表达式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── joxa-cmp-ns.jxa               # namespace
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── joxa-cmp-spec.jxa             # spec
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上即为Joxa编译器实现各部分代码的所在文件。整个编译器实现从代码量上来说并不大。&lt;/p&gt;

&lt;h3 id=&#34;24-数据类型&#34;&gt;2.4 数据类型&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#24-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;与Elixir在Erlang数据类型的基础上添加了Range、正则表达式、Unicode字符串等新数据类型不同，Joxa支持的数据类型与Erlang保持一致，并没有添加新的数据类型，所有的数据类型包括如下几种&lt;a href=&#34;#16&#34;&gt;[16]&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单类型：不定长整数，浮点数，原子&lt;/li&gt;
&lt;li&gt;系统类型：PID, Port, Reference&lt;/li&gt;
&lt;li&gt;集合类型: Tuple, Record，Map, List, Binary&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;各种数据类型的字面量语法请参考Joxa的在线文档。值得一提的是，围绕Record的各种操作，Joxa在语法上做了包装，便于解耦Record的内部实现与接口，提高了可用性，Elixir在这个方面走得更远，引入了Clojure的Protocol。另外一个常用的集合类型set是通过Erlang库提供的，并没有赋予特别的语法。&lt;/p&gt;

&lt;h3 id=&#34;25-特殊form及标准库基础原语&#34;&gt;2.5 特殊Form及标准库基础原语&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#25-%e7%89%b9%e6%ae%8aform%e5%8f%8a%e6%a0%87%e5%87%86%e5%ba%93%e5%9f%ba%e7%a1%80%e5%8e%9f%e8%af%ad&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;Joxa里面的特殊Form及标准库中的基础原语包括以下几个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;let*&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;&lt;br&gt;
用于绑定变量，不同于Erlang中的绑定操作或Clojure的&lt;code&gt;let&lt;/code&gt;操作，&lt;code&gt;let*&lt;/code&gt;并不支持Pattern Matching或解构，Pattern Matching或解构需要通过&lt;code&gt;case&lt;/code&gt;，标准库中的&lt;code&gt;let&lt;/code&gt;是一个用&lt;code&gt;let*&lt;/code&gt;和&lt;code&gt;case&lt;/code&gt;实现的对应支持Pattern Matching的版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;case&lt;/code&gt;&lt;br&gt;
整个Joxa语言中为数很少的一个支持Pattern Matching的原语之一，与Erlang里面在函数签名，变量匹配，&lt;code&gt;case&lt;/code&gt;语句等各种语法结构都可以做Pattern Matching不同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;receive&lt;/code&gt;&lt;br&gt;
接收消息，但没有对应的&lt;code&gt;send&lt;/code&gt;原语，这可以通过调用Erlang模块或OTP库接口实现，支持Pattern Matching&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;do&lt;/code&gt;&lt;br&gt;
分组表达式成一块，类似于Lisp里面的&lt;code&gt;progn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;&lt;br&gt;
以列表函数调用指定函数，类似于Lisp的&lt;code&gt;apply&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fn&lt;/code&gt;&lt;br&gt;
构造匿名函数，类似于Erlang的&lt;code&gt;fun&lt;/code&gt;，或Lisp的&lt;code&gt;lambda&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;defn&lt;/code&gt;, &lt;code&gt;defn+&lt;/code&gt;&lt;br&gt;
定义模块内可见，模块外可见函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;defspec&lt;/code&gt;&lt;br&gt;
用于定义前置声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;defmacro&lt;/code&gt;, &lt;code&gt;defmacro+&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;quasiquote&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;~@&lt;/code&gt;, &lt;code&gt;gensym&lt;/code&gt;, &lt;code&gt;macroexpand-1&lt;/code&gt;&lt;br&gt;
Macro操作，下一节再展开讨论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;&lt;br&gt;
namespace相关操作，源自于Clojure里面的对应物，要注意的是不同于Clojure默认会在所有namespace自动导入&lt;code&gt;clojure.core&lt;/code&gt;，Joxa并不会自动导入&lt;code&gt;joxa-core&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;try*&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;&lt;br&gt;
两者&lt;code&gt;catch&lt;/code&gt;用于异常捕取，用法跟Erlang里面的对应物类似，两者的区别在于是否支持Pattern Matching，类似于&lt;code&gt;let*&lt;/code&gt;和&lt;code&gt;let&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊常量，都以函数方式进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ($filename)       ;; 当前文件的文件名(连后缀)
  ($namespace)      ;; 当前的namespace
  ($line-number)    ;; 当前的行号
  ($function-name)  ;; 当前的函数名
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其它如&lt;code&gt;attr&lt;/code&gt;，&lt;code&gt;when&lt;/code&gt;等原语就不一一列举了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;26-macro&#34;&gt;2.6 Macro&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#26-macro&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;作为Lisp类语言的杀手级特性，以及表达DSL的终极利器，一直以来Macro在Lisp类语言中都有着重要的地位。Joxa中的Macro原语与Common Lisp或Clojure等之前的Lisp语言保持了一致，详细列出如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;defmacro     -- 定义模块内部Macro
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;defmacro+    -- 定义对模块外部可见Macro
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;quote        -- 抑制求值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;quasiquote   -- 对应Common Lisp里面的back quote，或Clojure里面的syntax quote，部分求值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~            -- unquote，对符号后面元素进行求值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~@           -- unquote-splicing，对符号后面的List元素进行求值并展开到当前位置
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gensym       -- 动态生成新变量，用于保证Macro健康(或称Macro卫生)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外为方便调试，标准库中提供了&lt;code&gt;macroexpand-1&lt;/code&gt;函数，用于单次展开Macro，这个函数也沿袭于传统的Lisp语言，但是并没有提供&lt;code&gt;macroexpand&lt;/code&gt;(&lt;code&gt;macroexpand-all&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;在Joxa里面使用Macro，跟之前的Lisp语言并没有什么不同，以一个标准库&lt;code&gt;joxa-core&lt;/code&gt;模块里的代码为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;defmacro+&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let &lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;args&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#0086b3&#34;&gt;rest &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;let*&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;process-arg-body&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;fn &lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;arg&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;arg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              ([&lt;span style=&#34;color:#008080&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;e&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;e&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~@&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              ((&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;. &lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;. &lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;rest&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;e&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;process-arg-body&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;rest&lt;/span&gt;))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;detail&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;erlang/error&lt;/span&gt; {&lt;span style=&#34;color:#990073&#34;&gt;:malformed-let-expression&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;detail&lt;/span&gt;})))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;process-arg-body&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;args&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Joxa在语法上直接定义为Lisp风格，因此在Macro的定义及使用上面，与传统一脉相承并无修改。在这个Macro定义里面，除了Pattern Matching，以及递归调用&lt;code&gt;process-arg-body&lt;/code&gt;之外，与传统Lisp语言并无不同，熟悉传统Lisp的人可以很快就读懂。对比的来看，在Elixir这样的非Lisp语言中引入Macro，由于上层语言的语法与AST并不一致，所以程序员必需记住/区分上层语言与AST两种环境，因此相对较为复杂，比如，在Elixir Macro的签名处Pattern Matching Erlang AST，就在以Elixir的语法编写的Macro定义中，暴露了底层的AST格式。这种复杂性虽然从设计上来说是必需的折衷，但在习惯了Lisp Macro的人看来可能不会太喜欢。Joxa作者Eric在2015年一次接受《This is not a Monad tutorial》的&lt;a href=&#34;https://medium.com/this-is-not-a-monad-tutorial/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-a09b15f53a2f&#34;&gt;采访&lt;/a&gt;中就表示过不喜欢Elixir Macro的复杂性。&lt;/p&gt;

&lt;h3 id=&#34;27-标准库概览&#34;&gt;2.7 标准库概览&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#27-%e6%a0%87%e5%87%86%e5%ba%93%e6%a6%82%e8%a7%88&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;Joxa的标准库只包括少数几个基本函数以及对OTP的简单包装。详细列出如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;joxa-core&lt;/code&gt;&lt;br&gt;
基本操作: &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;lte&lt;/code&gt;, &lt;code&gt;gte&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;incr&lt;/code&gt;, &lt;code&gt;decr&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;define&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;joxa-eunit&lt;/code&gt;&lt;br&gt;
eunit相关函数封装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;joxa-lists&lt;/code&gt;&lt;br&gt;
list相关的功能函数： &lt;code&gt;dolist&lt;/code&gt;, &lt;code&gt;hd&lt;/code&gt;, &lt;code&gt;tl&lt;/code&gt;, &lt;code&gt;foldl&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;lists-binding&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;joxa-records&lt;/code&gt;&lt;br&gt;
Record相关函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;joxa-shell&lt;/code&gt;&lt;br&gt;
REPL函数的简单实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;joxa-otp&lt;/code&gt;, &lt;code&gt;joxa-otp-gen-server&lt;/code&gt;, &lt;code&gt;joxa-otp-supervisor&lt;/code&gt;, &lt;code&gt;joxa-otp-application&lt;/code&gt;&lt;br&gt;
Erlang OTP相关接口的封装函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码规模很小，跟Elixir的标准库相比差得很远。其功能比较简陋，称之为标准库也许太大，或者称之为帮助函数更加准确。由于Joxa可以直接调用Erlang代码，因此功能缺失之处可由其它Erlang库补充。&lt;/p&gt;

&lt;h3 id=&#34;28-开发环境及工具链&#34;&gt;2.8 开发环境及工具链&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#28-%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e5%8f%8a%e5%b7%a5%e5%85%b7%e9%93%be&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;目前Joxa只有一个名为&lt;code&gt;joxa&lt;/code&gt;的命令行工具，用于编译Joxa源代码，启动REPL，这个工具的功能也比较简陋，跟Clojure的REPL还有很大的距离。源代码中有一个Emacs的Major Mode配置文件&lt;code&gt;emacs/joxa-mode.el&lt;/code&gt;，可以在用Emacs开发Joxa时设置缩进，关键字高亮，键绑定等。上面提到的与Slime和Swank集成，则尚未开发。&lt;/p&gt;

&lt;h3 id=&#34;29-项目状态&#34;&gt;2.9 项目状态&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#29-%e9%a1%b9%e7%9b%ae%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;Joxa从2011年底开始开发，一直到2013年初都比较活跃，这之后代码提交量变得相当少，在当前这个时间点(2015年8月)回头看看提交日志，已经有一年多的时间没有任何更新。虽然还未完成原来的设计目标，wiki上面的计划也有很多开发要做，但是由于作者Eric工作上比较忙，而Joxa社区实在太弱小，除作者之外并没有其它的人员贡献过大量代码，因此短期之内似乎项目状态不会重新变得活跃。在Google Group上有Joxa的邮件组，在近一年多时间内也相当少人发言。在应用上，除了作者Eric将Joxa用于编写他的创业项目之外，目前市面上没有看到其它的应用&lt;a href=&#34;#17&#34;&gt;[17]&lt;/a&gt;。综合来看，Joxa的项目状态是比较停滞的。&lt;/p&gt;

&lt;h2 id=&#34;3-总结&#34;&gt;3. 总结&amp;nbsp;&lt;a class=&#34;headline-hash no-text-decoration&#34; href=&#34;#3-%e6%80%bb%e7%bb%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;


&lt;p&gt;Joxa是一种基于Erlang VM的现代Lisp语言，有着简洁清晰的Lisp语法，支持强大的Macro，是在Erlang VM编写DSL的一个很好的载体，它无缝兼容Erlang VM平台，是一门功能全面的通用编程语言。它在语言设计及编译器实现方面质量优良，但目前完成度不高，工具链并不完整，市面上也少见应用。作为一门较新的基于Erlang VM的编程语言，它有待进一步的发展完善。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：&lt;/em&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[1]&lt;!-- raw HTML omitted --&gt; Eric Merritt是《Erlang and OTP in Action》(中文译本《Erlang/OTP并发编程实战》)一书的作者之一，Erlware项目联合创始人，Afiniate公司的CTO。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[2]&lt;!-- raw HTML omitted --&gt; 翻译自邮件原文&lt;br&gt;
It doesn’t actually mean anything. Many years ago it was an acronym for some project I wanted to start ‘Java oriented something or other’. I never made that project but I bought the domain and have kept it these years. Four letter domains are pretty uncommon these days, so I just decided to use it as the name for the language. Thats all.&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[3]&lt;!-- raw HTML omitted --&gt; 作为Erlang语言联合创始人以及Joe Armstrong的长期亲密战友，Robert Virding自从当年在爱立信计算机科学实验室开始，长期以来在Erlang的设计，标准库，编译器，发展推广等方方面面都做了杰出的贡献。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[4]&lt;!-- raw HTML omitted --&gt; Lisp-1和Lisp-2的区别在于函数与变量是否共用同一命名空间，一个详细的解释可以参考文章&lt;a href=&#34;http://ergoemacs.org/emacs/lisp1_vs_lisp2.html&#34;&gt;《What&amp;rsquo;s Lisp-1, What&amp;rsquo;s Lisp-2? Bad Jargon or Good Jargon?》&lt;/a&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[5]&lt;!-- raw HTML omitted --&gt; REPL是Read-Eval-Print Loop的缩写，最早被用于指代开发Lisp程序过程中，交互式命令行不断执行读取程序员的输入代码，对其进行求值并打印出求值结果的循环动作。后来这个概念被Python，Ruby及各种交互式命令行工具吸收并推广开来。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[6]&lt;!-- raw HTML omitted --&gt; Tony Arcieri是一位美国的软件工程师，他的博客见&lt;a href=&#34;http://tonyarcieri.com/&#34;&gt;这里&lt;/a&gt;。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[7]&lt;!-- raw HTML omitted --&gt; José Valim是一位波兰的软件工程师，他最被人熟知的两个身份是Ruby On Rails的核心成员以及Elixir编程语言的创始人。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[8]&lt;!-- raw HTML omitted --&gt; 比如Joe Armstrong于2013年中写了博客文章&lt;a href=&#34;http://joearms.github.io/2013/05/31/a-week-with-elixir.html&#34;&gt;《A Week with Elixir》&lt;/a&gt;盛赞了Elixir“结合了Ruby和Erlang的优良特性”，Dave Thomas于2014年发布了新书&lt;a href=&#34;https://pragprog.com/book/elixir/programming-elixir&#34;&gt;《Programming Elixir》&lt;/a&gt;向有其它语言经验的程序员提供了一本系统的教程。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[9]&lt;!-- raw HTML omitted --&gt; 译者注：&lt;a href=&#34;https://common-lisp.net/project/slime/&#34;&gt;Slime&lt;/a&gt;是Superior Lisp Interaction Mode for Emacs的缩写，它为Emacs提供了一整套交互式开发Common Lisp的功能集，包括编译，调试，文档查找等等，Slime是客户端，Swank是对应的服务器端，它们共同组成了一个强大的程序开发环境。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[10]&lt;!-- raw HTML omitted --&gt; 译者注：&lt;a href=&#34;http://erlang.org/doc/man/leex.html&#34;&gt;Leex&lt;/a&gt;和&lt;a href=&#34;http://erlang.org/doc/man/yecc.html&#34;&gt;Yecc&lt;/a&gt;是Erlang语言的Lex和Yacc工具集。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[11]&lt;!-- raw HTML omitted --&gt; CLOS是the Common Lisp Object System的缩写，是指在Common Lisp中实现面向对象机制的一系列代码库。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[12]&lt;!-- raw HTML omitted --&gt; 此图来自编译领域的经典著作《Compilers: Principles, Techniques, &amp;amp; Tools》第三版，中译本《编译原理》。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[13]&lt;!-- raw HTML omitted --&gt; 这个例子来自Eric Merritt 2012年8月在Chicago Erlang User Group上的技术分享《Joxa: A Full Featured Lisp on the Erlang VM》，录像视频见&lt;a href=&#34;https://vimeo.com/49116180&#34;&gt;这里&lt;/a&gt;.&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[14]&lt;!-- raw HTML omitted --&gt; LALR是LookAhead LR的缩写，LR中的L表示对输入进行从左到右的扫描，R表示反向构造出一个最右的推导序列。LALR是流行的自底向上语法分析方法。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[15]&lt;!-- raw HTML omitted --&gt; PEG是Packrat Expression Parsing的缩写，它是一种相对较新的自顶向下语法分析方法。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[16]&lt;!-- raw HTML omitted --&gt; 其中Map的语法支持由我添加，写此文时未进入主干分支。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[17]&lt;!-- raw HTML omitted --&gt; 从推广应用的角度来看，在2011年中开始开发的Elixir在各个基于Erlang VM的新编程语言上是走得最前的。&lt;/p&gt;
</description>
                
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/categories/lisp">Lisp</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/tags/erlang">Erlang</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/clojure">Clojure</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/elixir">Elixir</category>
                                
                            
                        
                    
                
                <guid>https://hhkbp2.com/joxa-a-lisp-programming-language-base-on-erlang-vm/</guid>
                <pubDate>Thu, 20 Aug 2015 20:34:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>嵌套反引用有害</title>
                <link>https://hhkbp2.com/nested-backquotes-considered-harmful/</link>
                
                
                <description>&lt;p&gt;本文翻译自&lt;a href=&#34;http://bc.tech.coop/blog/041205.html&#34;&gt;《Nested Backquotes considered harmful》&lt;/a&gt;，只用于学习，请勿用于其它用途。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好吧，我想嵌套反引用（nested backquote）不是真的有害，因为你的确可以用它来做一些没有它就很难做到的事情；然而，它又的确会导致非常难以理解的代码（它对于混乱代码比赛&lt;a href=&#34;#1&#34;&gt;[1]&lt;/a&gt;或许是有用的，但非常难以维护）。实际上，这篇文章的标题应该叫做“嵌套反引用令我头痛”，但我一直想写一篇标题叫做“那谁谁有害”的文章，于是，标题就是这个了。;-)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：如果你不知道什么是嵌套反引用，它为什么有用，或者感兴趣于了解更多关于写出或理解这种典型地由嵌套反引用生成的，用于生成代码的代码，那么Alan Bawden的杰出论文&lt;a href=&#34;www.linearity.org/bawden/ftp/pepm99.ps.gz&#34;&gt;《Quasiquotation in Lisp》&lt;/a&gt;值得一看（这是&lt;a href=&#34;http://groups.google.com/groups?hl=en&amp;amp;lr=&amp;amp;selm=41adc0bd%240%24276%24edfadb0f%40dread12.news.tele.dk&#34;&gt;Jens Axel Søgaard&lt;/a&gt;所推荐的）。Alan的论文描述了这项技术的历史和概况，而且读起来很有趣。Paul Graham在他的书《On Lisp》的第16章也谈到了嵌套反引用，他说&lt;a href=&#34;#2&#34;&gt;[2]&lt;/a&gt;：&lt;br&gt;
&lt;code&gt;为了定义一个定义宏的宏，我们通常会要用到嵌套的反引用。嵌套反引用的难以理解是出了名的。尽管最终我们会对那些常见的情况了如指掌，但你不能指望随便挑一个反引用表达式，都能看一眼，就能立即说出它可以产生什么。这不能归罪于 Lisp。就像一个复杂的积分，没人能看一眼就得出积分的结果，但是我们不能因为这个就把问题归咎于积分的表示方法。道理是一样的。难点在于问题本身，而非表示问题的方法。&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bruno Haible最近&lt;a href=&#34;groups.google.com/groups?hl=en&amp;amp;lr=&amp;amp;selm=con4h2%24odi%241%40laposte.ilog.fr&#34;&gt;在c.l.l.解释了避免嵌套反引用的两个不同方法&lt;/a&gt;。它们主要包含将嵌套反引用转换为简单反引用的做法。这两个方法他概述如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. 在内层使用LIST, APPEND等函数代替反引用
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. 使用包含反引用的辅助函数
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bruno为每个方法提供了例子。&lt;/p&gt;
&lt;p&gt;首先，下面给出的这段代码用了嵌套反引用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defmacro&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;once-only&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;rest&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#0086b3&#34;&gt;assert&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;every&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;symbolp&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt; ((&lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;nil&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#0086b3&#34;&gt;dotimes&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;i&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;)) (&lt;span style=&#34;color:#0086b3&#34;&gt;push&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;gensym&lt;/span&gt;) &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;every&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;side-effect-free?&lt;/span&gt; (&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;progn&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,,@&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;mapcar&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;lambda&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;tmp&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;``&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;,tmp&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;mapcar&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;lambda&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;tmp&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;,tmp&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原来的代码使用方法1转换后如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defmacro&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;once-only&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;rest&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#0086b3&#34;&gt;assert&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;every&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;symbolp&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt; ((&lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;nil&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#0086b3&#34;&gt;dotimes&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;i&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;)) (&lt;span style=&#34;color:#0086b3&#34;&gt;push&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;gensym&lt;/span&gt;) &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;every&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;side-effect-free?&lt;/span&gt; (&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;progn&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       (&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;let&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         (&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,@&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;mapcar&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;lambda&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;tmp&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;,tmp&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;mapcar&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;lambda&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;tmp&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;,tmp&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原来的代码使用方法2转换后如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-common-lisp&#34; data-lang=&#34;common-lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defun&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;construct-binding&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;variable&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;form&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;variable&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;form&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defun&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;construct-let-wrapper&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;bindings&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;body-form&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;bindings&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body-form&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;defmacro&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;once-only&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;rest&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#0086b3&#34;&gt;assert&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;every&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;symbolp&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt; ((&lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;nil&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#0086b3&#34;&gt;dotimes&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;i&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;)) (&lt;span style=&#34;color:#0086b3&#34;&gt;push&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;gensym&lt;/span&gt;) &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;every&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;side-effect-free?&lt;/span&gt; (&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;progn&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       (&lt;span style=&#34;color:#008080&#34;&gt;construct-let-wrapper&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         (&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,@&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;mapcar&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;lambda&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;tmp&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#008080&#34;&gt;construct-binding&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;,tmp&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;(&lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;mapcar&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;#&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;lambda&lt;/span&gt; (&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;tmp&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#990073&#34;&gt;&amp;#39;,tmp&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#008080&#34;&gt;variables&lt;/span&gt; &lt;span style=&#34;color:#008080&#34;&gt;temps&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;body&lt;/span&gt;)))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两个方法中的任一个，产生的代码的可读性都比原来代码好得多。&lt;/p&gt;
&lt;p&gt;作为Bruno建议方法的一种替代，也许你会考虑使用&lt;a href=&#34;http://www.cs.yale.edu/homes/dvm/&#34;&gt;Drew McDermott&lt;/a&gt;的BQ反引用工具（包含在&lt;a href=&#34;ftp://ftp.cs.yale.edu/pub/mcdermott/software/ytools.tar.gz&#34;&gt;YTools&lt;/a&gt;中）。Drew在&lt;a href=&#34;http://www.cs.yale.edu/homes/dvm/papers/ytdoc.pdf&#34;&gt;YTools手册&lt;/a&gt;中对这个反引用问题有一个很好的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反引用是Lisp的一个不可或缺的特性。然而在标准说明中它并非尽善尽美。我主要有两个不满：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当实现一个像反引用这样的机制时，需要3个东西：一个读取器，一个宏展开器，一个写入器。读取器将如&lt;code&gt; `(foo ,x)&lt;/code&gt;的字符序列转换为如&lt;code&gt;(backquote (foo (bq-comma x)))&lt;/code&gt;的内部形式（Allegro就是这样读取的）。之后宏展开器将backquote调用转变为像&lt;code&gt;(list &#39;foo x)&lt;/code&gt;构造函数形式。写入器将&lt;code&gt;(backquote (foo (bq-comma x)))&lt;/code&gt;输出为&lt;code&gt; `(foo ,x)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不幸的是，Common Lisp标准没有详细说明宏（macro）是什么。因此，它依赖于具体实现。对比来看，普通的引用（quote）有一个定义良好的内部形式&lt;code&gt;(quote x)&lt;/code&gt;，因此有一个定义良好的来自外部形式&lt;code&gt;&#39;x&lt;/code&gt;的转换。没有详细标准的问题就在于，要写一个你自己的工具配合读取器，宏取开器或写入器，是不可能的。例如，无法写一个可移植的代码遍历程序，针对反引用表达式来做一些特别的事情。事实上，一个Lisp实现甚至不要求有一个反引用的内部表示。读取器和宏展开器可以合并，以致于&lt;code&gt; `(foo ,x)&lt;/code&gt;可以读作&lt;code&gt;(list &#39;foo x)&lt;/code&gt;。此外反引用写入器的行为并非良好定义的，因为无法区别一个列表构造形式是不是由反引用转化来的。&lt;/p&gt;
&lt;p&gt;为什么要与宏展开器交互呢，这里有个例子。你或许也想和读取器有交互。假设你希望创造一个泛化的反引用读取宏（就叫它&lt;code&gt;!@&lt;/code&gt;吧），这个宏建造一些并非列表结构的东西，你可以将&lt;code&gt;(apply #&#39;make-a-foo (list &#39;baz a) l)&lt;/code&gt;简写作&lt;code&gt;!@(make-a-foo (baz ,a) ,@l)&lt;/code&gt;。当这个表达式&lt;code&gt;!@(...)&lt;/code&gt;被读入时，很多Lisp实现会报一个类似“Comma not inside a backquote”（逗号出现在非反引用表达式中）的错，没有可移植的办法来干预读取过程来使它变成合法的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于阐明嵌套反引用的规则是，逗号是与围绕它的最内层的反引用配对的。（同时提取它的参数到上下文中，以便下一个逗号匹配到下一个反引用，如此类推。）&lt;/p&gt;
&lt;p&gt;我想这是错误的，或者至少在某些情况下是错误的。我从左到右地读反引用代码，因此先看见最外层的反引用。人们会喜欢这样理解：从反引用的角度来看，所有在它里面的东西，除了用逗号标记的之外都是“不会动的（inert）”（即被引用住）。对于所有可能会出现在其中的表达式，除了反引用外，这是成立的。所以如果你正编辑一个复杂的反引用表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;(foo (bazaroo &#39;(fcn a ,x)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内层的引用不会“遮蔽”住&lt;code&gt;x&lt;/code&gt;使它免于被求值。但如果将内层的引用改成反引用，那么遮蔽就正正要发生。你必须把它改成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;(foo (bazaroo `(,fcn a ,&#39;,x)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;,&#39;,&lt;/code&gt;构造只是外观丑陋而已。它的唯一作用是将它的参数提取出最内层的反引用；你不能用&lt;code&gt;,,x&lt;/code&gt;，因为这是说“当外层的反引用被展开时对&lt;code&gt;x&lt;/code&gt;求值，得到&lt;code&gt;e&lt;/code&gt;，然后当最内层反引用展开时求值&lt;code&gt;e&lt;/code&gt;”。注意求值是次序是从外到内，然而嵌套反引用的规则是从内到外。非常，非常的令人迷惑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些不是巨大缺陷：99.9%的反引用不是嵌套的，而且几乎没人关心一个反引用的内部表示是什么。可是如果你感兴趣，文件&lt;code&gt;bq.lisp&lt;/code&gt;提供一个可选的实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，正如Common Lisp里大多数的事物一样，如果你不喜欢某些东西，你可以改变它！当你需要写这类嵌套反引用的代码时，你有（至少）4种不同的可以考虑的选择（基于你有多少嵌套反引用工作要做，还有你个人对代码风格／可读性的偏好）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. 使用嵌套反引用
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. 在内层使用LIST, APPEND等函数代替反引用
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3. 使用包含反引用的辅助函数
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4. 使用一个反引用的替代实现
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，出山吧，去写一些这样的代码：一种形式的代码不断的生成下一种形式，像生物进化的过程那样一代一代衍生。;-)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：&lt;/em&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[1]&lt;!-- raw HTML omitted --&gt; 即Obfuscation Contest。国际C语言混乱代码大赛（IOCCC, The International Obfuscated C Code Contest）是一项著名的国际编程赛事。&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;[2]&lt;!-- raw HTML omitted --&gt; 此段译文引用田春（伞哥）等人翻译的《On Lisp中文版》对应章节。&lt;/p&gt;
</description>
                
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/categories/lisp">Lisp</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://hhkbp2.com/tags/common-lisp">Common Lisp</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/backquote">Backquote</category>
                                 
                                    <category domain="https://hhkbp2.com/tags/macro">Macro</category>
                                
                            
                        
                    
                
                <guid>https://hhkbp2.com/nested-backquotes-considered-harmful/</guid>
                <pubDate>Sun, 10 Mar 2013 21:37:00 +0800</pubDate>
            </item>
        
    </channel>
</rss>


