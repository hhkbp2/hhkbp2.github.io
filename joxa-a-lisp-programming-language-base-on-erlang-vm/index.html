<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    
    

    
    
        <meta name="keywords" content="Erlang, Clojure, Elixir, Lisp"/>
    

    <title>
        
            Joxa: 一种基于 Erlang VM 的现代 Lisp 编程语言 ❚ hhkbp2&#39;s blog
        
    </title>

    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.1);
         --theme-heading-color: #413b39;
         --theme-body-color: #4d4642;
         --theme-hl1-color: #6d625f;
         --theme-hl2-color: #bdb5b3;
         --theme-hl2-transp-color: rgba(189, 181, 179, 0.5);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.2b8a165c1548d4a3fac47edd6e34071f93872f1131116f68d96d3b02ae7e15da.css">
    
    <link rel="preload" href="/css/refined.min.2b8a165c1548d4a3fac47edd6e34071f93872f1131116f68d96d3b02ae7e15da.css" as="style">

    



    
        <style>
         
         /* Background */ .bg { background-color: #ffffff; }
/* PreWrapper */ .chroma , .code-inline { background-color: #ffffff; }
/* Other */ .chroma .x , .code-inline .x {  }
/* Error */ .chroma .err , .code-inline .err { color: #a61717; background-color: #e3d2d2 }
/* CodeLine */ .chroma .cl , .code-inline .cl {  }
/* LineTableTD */ .chroma .lntd , .code-inline .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable , .code-inline .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; }
/* LineHighlight */ .chroma .hl , .code-inline .hl { background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt , .code-inline .lnt { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* LineNumbers */ .chroma .ln , .code-inline .ln { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* Line */ .chroma .line , .code-inline .line { display: flex; }
/* Keyword */ .chroma .k , .code-inline .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc , .code-inline .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd , .code-inline .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn , .code-inline .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp , .code-inline .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr , .code-inline .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt , .code-inline .kt { color: #445588; font-weight: bold }
/* Name */ .chroma .n , .code-inline .n {  }
/* NameAttribute */ .chroma .na , .code-inline .na { color: #008080 }
/* NameBuiltin */ .chroma .nb , .code-inline .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp , .code-inline .bp { color: #999999 }
/* NameClass */ .chroma .nc , .code-inline .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no , .code-inline .no { color: #008080 }
/* NameDecorator */ .chroma .nd , .code-inline .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni , .code-inline .ni { color: #800080 }
/* NameException */ .chroma .ne , .code-inline .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf , .code-inline .nf { color: #990000; font-weight: bold }
/* NameFunctionMagic */ .chroma .fm , .code-inline .fm {  }
/* NameLabel */ .chroma .nl , .code-inline .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn , .code-inline .nn { color: #555555 }
/* NameOther */ .chroma .nx , .code-inline .nx {  }
/* NameProperty */ .chroma .py , .code-inline .py {  }
/* NameTag */ .chroma .nt , .code-inline .nt { color: #000080 }
/* NameVariable */ .chroma .nv , .code-inline .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc , .code-inline .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg , .code-inline .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi , .code-inline .vi { color: #008080 }
/* NameVariableMagic */ .chroma .vm , .code-inline .vm {  }
/* Literal */ .chroma .l , .code-inline .l {  }
/* LiteralDate */ .chroma .ld , .code-inline .ld {  }
/* LiteralString */ .chroma .s , .code-inline .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa , .code-inline .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb , .code-inline .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc , .code-inline .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl , .code-inline .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd , .code-inline .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 , .code-inline .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se , .code-inline .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh , .code-inline .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si , .code-inline .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx , .code-inline .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr , .code-inline .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 , .code-inline .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss , .code-inline .ss { color: #990073 }
/* LiteralNumber */ .chroma .m , .code-inline .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb , .code-inline .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf , .code-inline .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh , .code-inline .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi , .code-inline .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il , .code-inline .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo , .code-inline .mo { color: #009999 }
/* Operator */ .chroma .o , .code-inline .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow , .code-inline .ow { color: #000000; font-weight: bold }
/* Punctuation */ .chroma .p , .code-inline .p {  }
/* Comment */ .chroma .c , .code-inline .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch , .code-inline .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm , .code-inline .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 , .code-inline .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs , .code-inline .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp , .code-inline .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf , .code-inline .cpf { color: #999999; font-weight: bold; font-style: italic }
/* Generic */ .chroma .g , .code-inline .g {  }
/* GenericDeleted */ .chroma .gd , .code-inline .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge , .code-inline .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr , .code-inline .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh , .code-inline .gh { color: #999999 }
/* GenericInserted */ .chroma .gi , .code-inline .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go , .code-inline .go { color: #888888 }
/* GenericPrompt */ .chroma .gp , .code-inline .gp { color: #555555 }
/* GenericStrong */ .chroma .gs , .code-inline .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu , .code-inline .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt , .code-inline .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl , .code-inline .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w , .code-inline .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */

/* GenericHeading, GenericSubheading */
.chroma .gh, .code-inline .gh,
.chroma .gu, .code-inline .gu {
    font-weight: bold;
}

/* Do not highlight error in pink background */
/* Error */
.chroma .err, .code-inline .err {
    background-color: inherit;
}

/* LineTable */
.chroma .lntable, .code-inline .lntable {
    width: auto;
    overflow-x: auto; /* Make the code block horizontally scrollable on narrow viewports. */
    display: block;
}

/* LineNumbersTable, LineNumbers, Line, LineHighlight */
/* Prevent the highlight from creating a strange artifact on line numbers. */
.chroma .lnt, .code-inline .lnt,
.chroma .ln, .code-inline .ln,
.chroma .line, .code-inline .line,
.chroma .hl, .code-inline .hl {
    display: flex;
}

/* Set the line highlight color to match the site's theme. */
/* LineHighlight */
.chroma .hl, .code-inline .hl {
    background-color: var(--theme-hl2-transp-color); /* This var is set in the head.html partial. */
}

/* Do not set the background color of inline src code*/
.chroma.inline-src, .code-inline {
    background-color: inherit;
}

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.ff4d50a4c0c1d811d4910eb648811ac9021a1cb6fece2dfd8c6c271d0cdacd0b.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.ff4d50a4c0c1d811d4910eb648811ac9021a1cb6fece2dfd8c6c271d0cdacd0b.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="Joxa: 一种基于 Erlang VM 的现代 Lisp 编程语言" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hhkbp2.com/joxa-a-lisp-programming-language-base-on-erlang-vm/" />

    
    


    
        <meta property="article:published_time" content="2015-08-20T20:34:00&#43;08:00"/>
    
    
        <meta property="article:modified_time" content="2015-08-20T20:34:00&#43;08:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Joxa: 一种基于 Erlang VM 的现代 Lisp 编程语言"/>
<meta name="twitter:description" content="" />


    
    
    
     





    <meta name="author" content=""/>



    
    
    
    <meta name="hugo-build-date" content=""/>
    <meta name="hugo-commit-hash" content=""/>
    <meta name="generator" content="Hugo 0.118.2">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://hhkbp2.com/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://hhkbp2.com/about/">About</a></li>
            
        
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">hhkbp2&#39;s blog</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Computer, programming and stuff.
                    </div>
                </header>

                








<article class="post h-entry posts">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__lisp__"
                                
                                
                                title="See all 5 posts categorized in ‘Lisp’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/categories/lisp/">Lisp</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__erlang__"
                                
                                
                                title="See all 4 posts tagged with ‘Erlang’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/tags/erlang/">Erlang</a>
                            </li>
                        
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__clojure__"
                                
                                
                                title="See all 3 posts tagged with ‘Clojure’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/tags/clojure/">Clojure</a>
                            </li>
                        
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__elixir__"
                                
                                
                                title="See all 2 posts tagged with ‘Elixir’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/tags/elixir/">Elixir</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">Joxa: 一种基于 Erlang VM 的现代 Lisp 编程语言</h1>

        
        <data class="u-url" value="https://hhkbp2.com/joxa-a-lisp-programming-language-base-on-erlang-vm/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2015-08-20T20:34:00+0800" class="dt-published" title="Published date">Aug 20, 2015</time>
        
        
    </div>


        </div>
         






    </header>

    <div class="content">
        


        





                       


        


        <div class="e-content">
            




<p><a href="http://joxa.org/">Joxa</a>是一种基于Erlang VM的现代Lisp编程语言，创始人是美国的Eric Merritt<a href="#1">[1]</a>。通过在Erlang VM上引入一个精心设计的Lisp语法，它保留了Lisp和Erlang两者的众多优点：简洁而且语义清晰的Lisp语法，强大的Macro，鼓励交互式开发，支持高并发，函数式风格等，并且与现有的Erlang平台保持良好兼容。它是一门功能全面的通用编程语言。</p>
<p>Joxa的官方网站是<a href="http://joxa.org/">joxa.org</a>，在这个官方网站上，有它的源代码<a href="https://github.com/joxa/joxa">github地址</a>，以及<a href="http://docs.joxa.org/en/latest/">在线文档</a>。为什么这门编程语言取名为Joxa呢？关于Joxa这个名字的由来，Eric Merritt曾经对我在邮件组的提问做过如下解释：</p>
<blockquote>
<p>其实这个名字并无特别的意义。很多年前我想开始一个“基于Java的某个项目”，于是有了它的缩写Joxa这个名字。这个项目从来没有开始做过，但我把域名买下来了并一直持有着。到今天，4个字母的域名已经很少能注册到了，所以我决定用它来做为这门语言的名字。<a href="#2">[2]</a></p>
</blockquote>
<p>除了名字开头有个字母&quot;J&quot;，Joxa与Java并没有太大的关系了，Joxa主要受到了Erlang及基于JVM的编程语言Clojure的影响。下面我们先介绍一下Erlang和Clojure，再讨论Joxa受到了它们的哪些影响。</p>

<h2 id="1-erlang-clojure以及joxa">1. Erlang, Clojure以及Joxa&nbsp;<a class="headline-hash no-text-decoration" href="#1-erlang-clojure%e4%bb%a5%e5%8f%8ajoxa">#</a></h2>



<h3 id="11-erlang高并发的函数式容错编程语言">1.1 Erlang，高并发的函数式容错编程语言&nbsp;<a class="headline-hash no-text-decoration" href="#11-erlang%e9%ab%98%e5%b9%b6%e5%8f%91%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8f%e5%ae%b9%e9%94%99%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80">#</a></h3>


<p>Erlang是一门通用的并发程序设计语言，它由瑞典爱立信的Joe Armstrong在上世纪80年代开发，并于1998年对外开源，Erlang这个名字来源自丹麦数学家及统计学家Agner Krarup Erlang。经过近30年的发展，Erlang目前是支持高并发的编程语言翘楚之一，它在语言层面封装了Actor模型，实现了用户空间的轻量级进程，将消息传递作为Actor间通信的唯一方式，避免了由传统的线程和锁在并发方面的限制与缺点。Erlang被设计为电信级系统的编程语言，强调分布式，容错，软实时和公平调度，在语法上它主要受到Prolog及Lisp的影响，保留了函数式，动态，交互式开发等特点。具体来讲，Erlang这个名字可以分成3个方面的要素：</p>
<ol>
<li>编程语言Erlang本身</li>
<li>总称为OTP的一系列程序设计原则及代码库</li>
<li>称为Erlang VM或BEAM的Erlang虚拟机</li>
</ol>
<p>Erlang设计于近30年前，因此从现在的角度来看，它在语法，编程环境(包括文档等)及工具链等方面有很多地方都有改进空间。由于Erlang VM是目前工业界支持高并发的最成熟的VM之一，大量技术专家及工程师们在上面投入了无数的工作，通过在Erlang VM上设计一门新语言来重用Erlang VM的优良特性，既能发挥Erlang VM的长处，又能改善Erlang语言本身在语法、工具链等方面的缺点，扬长而避短，是比较完美的方案。业界近几年涌现了众多基于Erlang VM的编程语言，下面介绍其中几种：</p>
<ol>
<li>LFE<br>
<a href="http://lfe.io/">LFE</a>是Lisp Flavored Erlang的缩写，它是由Robert Virding<a href="#3">[3]</a>于2007年开始开发的一门函数式的并发的通用编程语言，LFE采用了Lisp-2<a href="#4">[4]</a>风格的语法，通过将LFE代码编译为Core Erlang代码运行在BEAM上，保留了Erlang VM分布式，容错，软实时等优点，同时支持Lisp Macro，使得LFE兼有强大的元编程能力，并实现了一个功能丰富的REPL<a href="#5">[5]</a>。</li>
<li>Reia<br>
<a href="http://reia-lang.org/">Reia</a>是一门基于Erlang VM上的类似Ruby的脚本编程语言，它由Tony Arcieri<a href="#6">[6]</a>于2010年中开始开发，它在Erlang VM的分布式，并发，容错，热更新的基础之上，引入了Ruby的友好语法，灵活的代码块，反射及元编程功能力。遗憾的是，Reia在2011年宣布不再更新。</li>
<li>Elixir<br>
<a href="http://elixir-lang.org/">Elixir</a>是一门动态的函数式编程语言，它由José Valim<a href="#7">[7]</a>于2012年开发。Elixir同样采用了类Ruby的语法，通过支持强大的Macro功能，它在简洁的语言核心上，建立了一系列的标准库，包括Unicode字符串及相关操作，重写了单元测试框架，丰富的数据类型等，它吸收了Clojure的Protocol，严格和惰性API，还提供了现代的交互命令行，脚本相关的库函数及项目管理工具。通过将Elixir代码编译为Erlang AST，Elixir得以重用Erlang VM的高并发及高效率，克服了Ruby在并发方面的缺陷。由于得到Jose及其它Ruby界牛人的喜爱及宣传<a href="#8">[8]</a>，Elixir在近两年开始流行起来。</li>
</ol>
<p>由于本文主要是讲Joxa，上述这几种编程语言只是简单带过，就不详细展开了。</p>
<p>上面几种编程语言的设计方案虽然有很多不同之处，但从整体思路上几乎是相同的，那就是：通过将代码编译成为Erlang VM上的代码，良好兼容Erlang VM，于是保留了上述3要素中的后两点，同时从头设计语言的语法，并在标准库，工具链等一些方面做补充完善。Joxa的设计也是类似，它选择了Lisp做为Erlang VM上的新语言，不过它走了一条和LFE不同的道路。Eric Merritt后来专门写了一个博客文章<a href="http://blog.ericbmerritt.com/2012/02/21/differences-between-joxa-and-lfe.html">《Differences Between Joxa and LFE》</a>来谈Joxa和LFE的不同之处，他说：</p>
<blockquote>
<p>最主要和重要的区别在于这两门语言的目标。我认为Robert实现LFE的主要目标在于提供一个可变的语法可扩展的Erlang版本，如此一来人们就可以在需要时改变语言。同时我坚信Robert喜欢实现编程语言，他应该很享受实现LFE的过程。我当然也乐于实现Joxa，然而，当坐下来实现Joxa的时候我怀有一些非常特定的目标：</p>
<ol>
<li>我需要一个用于开发DSL(Domain Specific Language，领域特定语言)的平台</li>
<li>我想要一个更具交互性和动态的开发环境。类似于Slime和Swank那种<a href="#9">[9]</a></li>
<li>我希望充分利用所有已经存在的相当优秀的Lisp工具</li>
</ol>
<p>上述每点都可以在Erlang里面解决。例如，我可以用Leex和Yecc<a href="#10">[10]</a>实现DSL，但我实现DSL的最好体验总是来自Lisp：使用Lisp函数和Macro来打造这些DSL。不过我使用Erlang有很长时间了，我不愿意放弃Erlang VM上面的优良功能来换成Lisp的种种优点。唯一的解决方法似乎只有使用一门基于Erlang VM之上的Lisp语言。</p>
<p>显而易见的首先选择是LFE，于是我花了几周时间深入研究这门语言和它的内部实现。最后我得到这个结论：它并没有满足我的需求。剩下的唯一退路就是我自己重新创造一门语言(同时也有一点怀疑自己不太明智)。</p>
</blockquote>
<p>从整体来看，LFE更像一门披着Lisp外衣的Erlang，相当于给原来Erlang语法添加了括号和Macro，这与Eric Merritt理想中的Erlang VM上的Lisp语言相去甚远，于是他创造了Joxa，而Joxa的语法及风格受到Clojure的影响更大。为什么Clojure能受到Eric的如此青睐呢？它到底有什么出众之处呢？下面我们来了解一下。</p>

<h3 id="12-clojurejvm上的函数式lisp编程语言">1.2 Clojure，JVM上的函数式Lisp编程语言&nbsp;<a class="headline-hash no-text-decoration" href="#12-clojurejvm%e4%b8%8a%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8flisp%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80">#</a></h3>


<p>Clojure是一门动态的强类型编程语言，作者是Rich Hickey。它寄居在JVM之上，设计成能够与JVM/Java良好互操作，既利用了JVM所提供的成熟高效的运行环境，也兼容众多流行的Java库与框架，同时它采用了Lisp语法和Macro，非常便于表达DSL，加上一套函数式的持久数据结构，并提供并发机制及惰性语义，使得简洁优雅语言成为函数式编程，并发编程的良好载体，同时重用了成熟流行的JVM平台，使得它便于在现有Java程序员中推广并流行，在这一点上区别于以往所有独立开发的函数式语言。此外它也吸收了Java中的面向对象思想和CLOS<a href="#11">[11]</a>，发展出Protocol及多重方法。另外，Clojure自带一系列丰富的标准库，定义了一套项目管理规范，并提供了优秀的项目工具及REPL，使得它在开发环境，交互式开发方面成为佼佼者。</p>
<p>Clojure设计成为Java的一个库包，Clojure代码会编译成JVM byte code，正因为它以一种非侵入性的方式运行在JVM之上，所以在函数式的语言层面，会有一些其它函数式语言不可能出现的“瑕疵”，例如函数没有尾递归优化。兼容JVM平台的已有代码，在重用/连接已有项目方面既是一种优势，但有时混合函数式与命令式代码也会产生实际冲突。在并发方面，语言提供的多种并发原语，delay, future, promise，agent，STM等虽然强大，但从语言整体来看比较复杂。Clojure的很多地方可以体会到作者有意保持简单与功能(复杂)的平衡，在设计上做了务实折衷的克制。与此相反，另外一个基于JVM的语言Scala在设计上就显得博爱放任，看到各个好的特性就收入到语言当中，宛如中国古代的皇帝举国征选妃嫔。</p>
<p>相比各种“主流”编程语言，Clojure至今仍是小众语言，虽然如此，它的推出仍然不可谓不成功，既培养了一个健康壮大的社区，也在市场上占有一定的流行度，产生了一批具有相当影响力的项目，如流式数据处理框架<a href="https://storm.apache.org/">Storm</a>等。Clojure成功地向人们展示了这几个可能性：</p>
<ol>
<li>在JVM平台实现一个函数式，并发的动态编程语言</li>
<li>通过融合持久数据结构，Protocol等优异特性，复兴Lisp</li>
<li>如何语言设计上在功能、简单与务实之间取得折衷平衡并树立起自身的特色</li>
</ol>
<p>正因为有些如此之多的优点，Clojure才对程序员们有着如此之大的吸引力。也难怪身为老Lisp爱好者的Eric Merritt在创造Joxa时会受到Clojure的较大的影响。下面我们来谈谈Joxa的设计。</p>

<h3 id="13-joxa-erlang-vm上的新lisp编程语言">1.3 Joxa, Erlang VM上的新Lisp编程语言&nbsp;<a class="headline-hash no-text-decoration" href="#13-joxa-erlang-vm%e4%b8%8a%e7%9a%84%e6%96%b0lisp%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80">#</a></h3>


<p>对照上述多种语言的实现，Joxa的设计主要有如下几个要点：</p>
<ol>
<li>上层语言为Lisp，主要目标为用于写DSL(或者作为其它上层Lisp的元语言)，语言的核心部分要简洁</li>
<li>底层将Joxa代码编译成Erlang VM代码，将Joxa代码映射到Erlang上的对应语法结构，比如Joxa里面的函数即为Erlang函数</li>
<li>语言核心之外提供REPL，方便编译/执行脚本的命令行工具等</li>
</ol>
<p>其中Lisp的语法可以参考简洁，优雅的Clojure，由于Erlang VM与JVM有着非常多的差异，正如Erlang语言与Java语言有着非常多的差异，所以可以预期的是，Joxa在语法上面不能完全保持与Clojure一致，同时这里面有一个目标用户的问题：Joxa更多的是为了Clojure程序员转向Erlang平台而设计，还是为了Erlang程序员转向Lisp而设计。若为前者，就尽量保留可能多的Clojure语法及规范，若为后者则将语法尽可能向Erlang靠拢比较理想。这时Joxa选择了后一种，即认为Joxa主要是解决Erlang现有的问题，所以从语法上来考虑，最后出来的结果很可能是一种Lisp与Erlang的独一无二的新结合。所有的Lisp语言从结构上来看，都具有一种类似数学的体系结构，包括以下几个部分：</p>
<ol>
<li>一切表达式皆为List，List有两种，原子及函数调用。代码即数据(总结为同像性)</li>
<li>7个基本原语(又称之为特殊Form)加上可以操纵语言本身的Macro，两者作为核心，在此之上演化出整个语言</li>
</ol>
<p>这就像数学体系，最核心的部分是几条基本原理，然后通过逻辑推导，演化出其它数学分支以构成整个体系，可以不断向外扩展。Joxa将会有同样的结构，核心部分将保持尽可能的简洁，只包括基本原语及Macro，极简的核心既节省开发成本，也给外延留下尽可能大的空间。此处的外延包括针对特定问题领域而言的DSL，也包括其它上层的Lisp语言，从本质上来说这两者本来就没有区别，只不过因为针对的范围有大有小所以说法不同。从语法设计上，Joxa会跟LFE有如下的不同：</p>
<ol>
<li>Joxa会是Lisp-1，而LFE是Lisp-2</li>
<li>Joxa的语法会向Lisp靠拢，而LFE更像Erlang</li>
<li>Joxa中Macro求值语义与Lisp更为一致，而LFE的Macro求值语义与函数求值语言不同</li>
</ol>
<p>为了保持与Erlang VM现有的平台等保持无缝兼容，以充分利用现有的Erlang VM的开发规范与代码库等，第2点是必需的。将Joxa建立在Erlang VM平台的生态环境之上，固然是因为作者对Erlang VM的熟悉与喜欢，客观上也可以充分发挥Erlang生态的优势。从上面的叙述也可以看到，众多Erlang VM上的非Erlang编程语言也采用了这种“无缝兼容”设计，虽然它们在实现层面会有一些不同之处。这一点同时确定了Joxa将会保留Erlang的一些语言特性，例如按文件划分的模块化，函数式风格，代码要求先通过编译等。</p>
<p>第3点与开发环境相关，REPL是各种Lisp方言已经是司空见惯了，Erlang在设计的时候也吸收了这个概念，但是实现得不如Lisp的REPL那么好用，比如强制输入为表达式(每行的后面必须输入&quot;.&ldquo;号)，Record不能用等。Joxa的REPL会参考Clojure与Erlang的REPL，结合前者的完整性和后者的功能，在易用性给予特别的关注。同时针对编译、脚本化等开发流程中的各个阶段都提供编辑器、命令行工具等支持。</p>

<h2 id="2-设计与实现细节">2. 设计与实现细节&nbsp;<a class="headline-hash no-text-decoration" href="#2-%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">#</a></h2>


<p>下面我们来详细讨论Joxa的设计与实现。根据上述的设计要点，要将Joxa代码要编译成Erlang VM代码，必需先熟悉Erlang代码的编译过程，在此过程中找出合适的切入点。</p>

<h3 id="21-erlang编译过程">2.1 Erlang编译过程&nbsp;<a class="headline-hash no-text-decoration" href="#21-erlang%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b">#</a></h3>


<p>一个经典的编译过程可以分为如下图所示的多个阶段：</p>
<p><img src="classic_compilation.png" alt="传统编译过程的各阶段"></p>
<p>图1 经典编译过程的各阶段<a href="#12">[12]</a></p>
<p>经典的编译过程可以分为词法分析，语法分析，语义分析，中间代码生成，中间代码优化，机器码生成等多个阶段。Erlang的代码编译过程跟经典的编译过程基本一致，也可以分成类似的多个阶段，各个阶段的输入输出如下图所示：</p>
<p><img src="erlang_compilation.png" alt="Erlang编译过程的各阶段"></p>
<p>图2 Erlang编译过程各阶段的输入输出</p>
<p>其中Core Erlang为于Erlang代码与VM内部中间代码之间的一层，它是在1999年前后提出的一种BEAM(Erlang VM的最新实现)上的语言，它被设计为：</p>
<ol>
<li>语法清晰简单，严格的更高阶函数式语言</li>
<li>尽可能规范化，以便相关代码遍历工具的开发</li>
<li>从Erlang代码向Core Erlang代码的翻译应该直白，从Core Erlang向VM内部实现中间代码的翻译也应该简单</li>
<li>有良好定义的文本表示形式，语法简单无歧义，便于人阅读，调试及测试</li>
</ol>
<p>由于Core Erlang是清晰简单，有良好定义的文本语言，便于作为目标语言，而且Erlang的代码优化和错误检测大多都在Core Erlang层进行，如果我们要在Erlang VM打造新编程语言，那么将新语言的代码编译成Core Erlang(或AST)，将会是一个很好的解决方案。很多Erlang VM上的语言都选择了这种方案，比如LFE，但也有语言选择了编译成Erlang AST，比如Elixir，精通Elixir Macro的人对Erlang AST应该比较熟悉。相对于Core Erlang，Erlang AST更接近于Erlang本身，层次也更高。Core Erlang相关的功能定义在<code>cerl.erl</code>这个模块里面，包括对如模块、函数等各种Erlang语言结构的初始化、操纵等功能的一系列函数。</p>

<h3 id="22--一个简单例子">2.2  一个简单例子&nbsp;<a class="headline-hash no-text-decoration" href="#22--%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e4%be%8b%e5%ad%90">#</a></h3>


<p>下面举一个简单的Hello World程序作为例子<a href="#13">[13]</a>，让读者对Erlang AST与Core Erlang有一个感性认识。原始的Erlang代码如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>-<span style="color:#800080">module</span>(test).
</span></span><span style="display:flex;"><span>-<span style="color:#800080">export</span>([hello_world<span style="color:#000;font-weight:bold">/</span><span style="color:#099">0</span>]).
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">hello_world</span>() <span style="color:#000;font-weight:bold">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#555">io</span>:<span style="color:#900;font-weight:bold">format</span>(<span style="color:#d14">&#34;Hello World&#34;</span>).
</span></span></code></pre></div><p>对应的Core Erlang代码如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>module &#39;test&#39; [&#39;hello_world&#39;<span style="color:#000;font-weight:bold">/</span><span style="color:#099">0</span>]
</span></span><span style="display:flex;"><span>    attributes []
</span></span><span style="display:flex;"><span>&#39;hello_world&#39;<span style="color:#000;font-weight:bold">/</span><span style="color:#099">0</span> <span style="color:#000;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">fun</span> () <span style="color:#000;font-weight:bold">-&gt;</span>
</span></span><span style="display:flex;"><span>        call <span style="color:#555">&#39;io&#39;</span>:<span style="color:#900;font-weight:bold">&#39;format&#39;</span>
</span></span><span style="display:flex;"><span>            (<span style="color:#a61717;background-color:#e3d2d2">“</span><span style="color:#008080">Hello</span> <span style="color:#008080">World</span><span style="color:#a61717;background-color:#e3d2d2">”</span>)
</span></span></code></pre></div><p>对比两份代码，可以看到Core Erlang与Erlang之间的映射还是很直观的。将原始的Erlang代码编译为Erlang AST，可以得到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>[{attribute,<span style="color:#099">1</span>,module,test},
</span></span><span style="display:flex;"><span> {attribute,<span style="color:#099">2</span>,export,[{hello_world,<span style="color:#099">0</span>}]},
</span></span><span style="display:flex;"><span> {function,<span style="color:#099">2</span>,hello_world,<span style="color:#099">0</span>,
</span></span><span style="display:flex;"><span>   [{clause,<span style="color:#099">2</span>,[],[],
</span></span><span style="display:flex;"><span>     [{call,<span style="color:#099">3</span>,
</span></span><span style="display:flex;"><span>       {remote,<span style="color:#099">3</span>,{atom,<span style="color:#099">3</span>,io},{atom,<span style="color:#099">3</span>,format}},
</span></span><span style="display:flex;"><span>         [{string,<span style="color:#099">3</span>,<span style="color:#d14">&#34;Hello World&#34;</span>}]}]}]}]
</span></span></code></pre></div><p>编译为Core Erlang AST即得到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>{c_module,[],
</span></span><span style="display:flex;"><span>  {c_literal,[],test},
</span></span><span style="display:flex;"><span>    [{c_var,[],{hello_world,<span style="color:#099">0</span>}}],
</span></span><span style="display:flex;"><span>      [],
</span></span><span style="display:flex;"><span>     [{ {c_var,[],{hello_world,<span style="color:#099">0</span>}},
</span></span><span style="display:flex;"><span>       {c_fun,[<span style="color:#099">2</span>,{file,[]}],
</span></span><span style="display:flex;"><span>         [],
</span></span><span style="display:flex;"><span>         {c_call,[<span style="color:#099">3</span>,{file,[]}],
</span></span><span style="display:flex;"><span>           {c_literal,[<span style="color:#099">3</span>,{file,[]}],io},
</span></span><span style="display:flex;"><span>           {c_literal,[<span style="color:#099">3</span>,{file,[]}],format},
</span></span><span style="display:flex;"><span>           [{c_literal,[<span style="color:#099">3</span>,{file,[]}],
</span></span><span style="display:flex;"><span>              <span style="color:#d14">&#34;Hello World&#34;</span>}]}}}]}
</span></span></code></pre></div><p>对比两者，容易看出Erlang AST更高层更抽象，Core Erlang AST更底层更规范。</p>

<h3 id="23-编译器">2.3 编译器&nbsp;<a class="headline-hash no-text-decoration" href="#23-%e7%bc%96%e8%af%91%e5%99%a8">#</a></h3>


<p>下面我们继续来讨论Joxa的编译过程，由于Core Erlang(及AST)可以由Erlang编译器编译成最终的机器码，我们只需将Joxa代码编译成Core Erlang AST便可实现将Joxa编译成机器码整个编译过程，从编译领域的分类来看，目标生成的代码是Core Erlang AST，操纵Core Erlang AST可以直接调用<code>cerl.erl</code>的接口函数，因此编译器后端这一块相对是比较简单的，重点在于前端部分：即将Joxa代码编译成Core Erlang AST。由于Joxa是Lisp语法，Lisp代码以括号划分边界的代码树的方式来表示，本身就已经有良好的结构，所以前端部分也比较简单。区别于LFE或Elixir用Leex或Yecc来生成LALR<a href="#14">[14]</a>式Lexer与Parser，Joxa采用了手写PEG<a href="#15">[15]</a> Lexer和Parser的方式。PEG编译器的代码量较小，Joxa编译器是在Erlang PEG生成器<a href="https://github.com/seancribbs/neotoma">Neotoma</a>生成代码的基础上写成的。(本节涉及到很多编译领域的术语或技术，由于本文主要是介绍Joxa，篇幅所限故不会详细解释这些术语或技术，有兴趣的读者可以自行寻找相关的资料做进一步了解)</p>
<p>特别值得一提的是，Joxa的编译过程是自举的，即Joxa编译器本身是由Joxa代码编写的，这与LFE或Elixir的编译器用Erlang编写不同。Joxa的自举要求先有一份以Core Erlang AST格式存在的具有正常编译功能的代码，这部分代码在Joxa的Github代码库中，相对根目录的路径是<code>src/ast</code>(后面给出所有的代码路径都相对于根目录)。通过用Erlang编译器将这份AST代码编译成BEAM代码，然后就得到一个能直接在BEAM上执行的Joxa编译器，然后就可以运行此编译器，将编译器的Joxa源代码编译成Core Erlang AST格式。整个流程和依赖如下图所示：</p>
<p><img src="joxa_self_bootstrap.png" alt="Joxa的自举及编译流程"></p>
<p>图3 Joxa的自举及编译流程</p>
<p>由上图可以看到整个流程三个步骤是一个循环，要成功实现自举，必然要先实现其中的一个部分，在此基础上才能实现其中其它两个部分。在Joxa的编译器实现中，AST这部分先由作者Eric人手先写出基本的语法解析功能，然后再编写对应功能的编译器的Joxa代码，用AST编译出来可执行的编译器，去验证对应的Joxa代码，然后再按此流程不断添加更多的功能，错误一般出现在编译Joxa代码的时候，此时遇到的错误是由新添加的AST代码还是Joxa代码引起的，有时并不容易定位出来。虽然Core Erlang简单清晰，但手写Core Erlang AST是相当繁琐的，而且由于Joxa语法本身还在不断演变，从头开发一个这样的自举编译器，其难度可以猜想是比较大的。我曾经为Joxa添加过Map语法的支持，对此开发流程的复杂性有较深的体会。编程语言的自举也可以按另外一个思路来做：先用另外一门常见的语言，比如C语言来写编译器，然后当语言的语法发展到比较稳定成熟的时候，再使用这门语言的本身来实现自身的编译器，由于已经有了一个能够工作经过充分检验的C编译器，所以自举的实现就有了一个可靠的保障，大大降低其难度。</p>
<p>编译器这部分的Joxa代码的路径是<code>src/joxa-cmp-*.jxa</code>(其中<code>*</code>符号表示通配)。按照编译器前端和后端的分类法，下面我们讨论一下各主要文件的代码分布。PEG的词法分析部分需要构造一系列对应于词素(lexeme)的正则表达式，首先需要有正则表达式的元操作的函数定义，所谓“元操作”，用各种编程语言里面的正则表达式的术语来说，即是元字符，比如&rdquo;*&ldquo;符号用于“匹配0个或多个”。在PEG里面元操作是通过函数来表达的，这部分的代码在<code>src/joxa-cmp-peg.jxa</code>。词素，比如注释或数字，它们的定义放在<code>src/joxa-cmp-lexer.jxa</code>。<code>src/joxa-cmp-parser.jxa</code>则包含Parser的代码。编译器的主要逻辑放在<code>src/joxa-compiler.jxa</code>，它调用Parser来解析读入的字符流，成功解析之后调用<code>make-forms</code>函数递归遍历解析得到的语法树来生成Core Erlang AST，在编译过程中会执行对函数调用的合法性检查，Macro的递归展开等动作。后端的代码按语义的分类分成下述多个文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>├── joxa-cmp-binary.jxa           # Binary
</span></span><span style="display:flex;"><span>├── joxa-cmp-call.jxa             # 函数调用
</span></span><span style="display:flex;"><span>├── joxa-cmp-case.jxa             # case语句
</span></span><span style="display:flex;"><span>├── joxa-cmp-defs.jxa             # 函数、宏定义
</span></span><span style="display:flex;"><span>├── joxa-cmp-expr.jxa             # 表达式
</span></span><span style="display:flex;"><span>├── joxa-cmp-joxa-info.jxa        # 模块info
</span></span><span style="display:flex;"><span>├── joxa-cmp-literal.jxa          # 常量，常量表达式
</span></span><span style="display:flex;"><span>├── joxa-cmp-ns.jxa               # namespace
</span></span><span style="display:flex;"><span>└── joxa-cmp-spec.jxa             # spec
</span></span></code></pre></div><p>以上即为Joxa编译器实现各部分代码的所在文件。整个编译器实现从代码量上来说并不大。</p>

<h3 id="24-数据类型">2.4 数据类型&nbsp;<a class="headline-hash no-text-decoration" href="#24-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">#</a></h3>


<p>与Elixir在Erlang数据类型的基础上添加了Range、正则表达式、Unicode字符串等新数据类型不同，Joxa支持的数据类型与Erlang保持一致，并没有添加新的数据类型，所有的数据类型包括如下几种<a href="#16">[16]</a>：</p>
<ol>
<li>简单类型：不定长整数，浮点数，原子</li>
<li>系统类型：PID, Port, Reference</li>
<li>集合类型: Tuple, Record，Map, List, Binary</li>
</ol>
<p>各种数据类型的字面量语法请参考Joxa的在线文档。值得一提的是，围绕Record的各种操作，Joxa在语法上做了包装，便于解耦Record的内部实现与接口，提高了可用性，Elixir在这个方面走得更远，引入了Clojure的Protocol。另外一个常用的集合类型set是通过Erlang库提供的，并没有赋予特别的语法。</p>

<h3 id="25-特殊form及标准库基础原语">2.5 特殊Form及标准库基础原语&nbsp;<a class="headline-hash no-text-decoration" href="#25-%e7%89%b9%e6%ae%8aform%e5%8f%8a%e6%a0%87%e5%87%86%e5%ba%93%e5%9f%ba%e7%a1%80%e5%8e%9f%e8%af%ad">#</a></h3>


<p>Joxa里面的特殊Form及标准库中的基础原语包括以下几个:</p>
<ul>
<li>
<p><code>let*</code>, <code>let</code><br>
用于绑定变量，不同于Erlang中的绑定操作或Clojure的<code>let</code>操作，<code>let*</code>并不支持Pattern Matching或解构，Pattern Matching或解构需要通过<code>case</code>，标准库中的<code>let</code>是一个用<code>let*</code>和<code>case</code>实现的对应支持Pattern Matching的版本</p>
</li>
<li>
<p><code>case</code><br>
整个Joxa语言中为数很少的一个支持Pattern Matching的原语之一，与Erlang里面在函数签名，变量匹配，<code>case</code>语句等各种语法结构都可以做Pattern Matching不同</p>
</li>
<li>
<p><code>receive</code><br>
接收消息，但没有对应的<code>send</code>原语，这可以通过调用Erlang模块或OTP库接口实现，支持Pattern Matching</p>
</li>
<li>
<p><code>do</code><br>
分组表达式成一块，类似于Lisp里面的<code>progn</code></p>
</li>
<li>
<p><code>apply</code><br>
以列表函数调用指定函数，类似于Lisp的<code>apply</code></p>
</li>
<li>
<p><code>fn</code><br>
构造匿名函数，类似于Erlang的<code>fun</code>，或Lisp的<code>lambda</code></p>
</li>
<li>
<p><code>defn</code>, <code>defn+</code><br>
定义模块内可见，模块外可见函数</p>
</li>
<li>
<p><code>defspec</code><br>
用于定义前置声明</p>
</li>
<li>
<p><code>defmacro</code>, <code>defmacro+</code>, <code>quote</code>, <code>quasiquote</code>, <code>~</code>, <code>~@</code>, <code>gensym</code>, <code>macroexpand-1</code><br>
Macro操作，下一节再展开讨论</p>
</li>
<li>
<p><code>use</code>, <code>require</code>, <code>as</code><br>
namespace相关操作，源自于Clojure里面的对应物，要注意的是不同于Clojure默认会在所有namespace自动导入<code>clojure.core</code>，Joxa并不会自动导入<code>joxa-core</code></p>
</li>
<li>
<p><code>try*</code>, <code>try</code><br>
两者<code>catch</code>用于异常捕取，用法跟Erlang里面的对应物类似，两者的区别在于是否支持Pattern Matching，类似于<code>let*</code>和<code>let</code></p>
</li>
<li>
<p>特殊常量，都以函数方式进行调用</p>
<pre><code>  ($filename)       ;; 当前文件的文件名(连后缀)
  ($namespace)      ;; 当前的namespace
  ($line-number)    ;; 当前的行号
  ($function-name)  ;; 当前的函数名
</code></pre>
</li>
<li>
<p>其它如<code>attr</code>，<code>when</code>等原语就不一一列举了。</p>
</li>
</ul>

<h3 id="26-macro">2.6 Macro&nbsp;<a class="headline-hash no-text-decoration" href="#26-macro">#</a></h3>


<p>作为Lisp类语言的杀手级特性，以及表达DSL的终极利器，一直以来Macro在Lisp类语言中都有着重要的地位。Joxa中的Macro原语与Common Lisp或Clojure等之前的Lisp语言保持了一致，详细列出如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>defmacro     -- 定义模块内部Macro
</span></span><span style="display:flex;"><span>defmacro+    -- 定义对模块外部可见Macro
</span></span><span style="display:flex;"><span>quote        -- 抑制求值
</span></span><span style="display:flex;"><span>quasiquote   -- 对应Common Lisp里面的back quote，或Clojure里面的syntax quote，部分求值
</span></span><span style="display:flex;"><span>~            -- unquote，对符号后面元素进行求值
</span></span><span style="display:flex;"><span>~@           -- unquote-splicing，对符号后面的List元素进行求值并展开到当前位置
</span></span><span style="display:flex;"><span>gensym       -- 动态生成新变量，用于保证Macro健康(或称Macro卫生)
</span></span></code></pre></div><p>另外为方便调试，标准库中提供了<code>macroexpand-1</code>函数，用于单次展开Macro，这个函数也沿袭于传统的Lisp语言，但是并没有提供<code>macroexpand</code>(<code>macroexpand-all</code>)。</p>
<p>在Joxa里面使用Macro，跟之前的Lisp语言并没有什么不同，以一个标准库<code>joxa-core</code>模块里的代码为例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#900;font-weight:bold">defmacro+</span> <span style="color:#000;font-weight:bold">let </span>(<span style="color:#900;font-weight:bold">args</span> <span style="color:#000;font-weight:bold">&amp;</span><span style="color:#0086b3">rest </span><span style="color:#008080">body</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#900;font-weight:bold">let*</span> (<span style="color:#900;font-weight:bold">process-arg-body</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#000;font-weight:bold">fn </span>(<span style="color:#900;font-weight:bold">arg</span>)
</span></span><span style="display:flex;"><span>            (<span style="color:#900;font-weight:bold">case</span> <span style="color:#008080">arg</span>
</span></span><span style="display:flex;"><span>              ([<span style="color:#008080">r</span> <span style="color:#008080">e</span>]
</span></span><span style="display:flex;"><span>               <span style="color:#000;font-weight:bold">`</span>(<span style="color:#900;font-weight:bold">case</span> <span style="color:#000;font-weight:bold">~</span><span style="color:#008080">e</span>
</span></span><span style="display:flex;"><span>                  (<span style="color:#000;font-weight:bold">~</span><span style="color:#008080">r</span> <span style="color:#000;font-weight:bold">~@</span><span style="color:#008080">body</span>)))
</span></span><span style="display:flex;"><span>              ((<span style="color:#900;font-weight:bold">r</span> <span style="color:#000;font-weight:bold">. </span>(<span style="color:#900;font-weight:bold">e</span> <span style="color:#000;font-weight:bold">. </span><span style="color:#008080">rest</span>))
</span></span><span style="display:flex;"><span>               <span style="color:#000;font-weight:bold">`</span>(<span style="color:#900;font-weight:bold">case</span> <span style="color:#000;font-weight:bold">~</span><span style="color:#008080">e</span>
</span></span><span style="display:flex;"><span>                  (<span style="color:#000;font-weight:bold">~</span><span style="color:#008080">r</span> <span style="color:#000;font-weight:bold">~</span>(<span style="color:#900;font-weight:bold">process-arg-body</span> <span style="color:#008080">rest</span>))))
</span></span><span style="display:flex;"><span>              (<span style="color:#900;font-weight:bold">detail</span> (<span style="color:#900;font-weight:bold">erlang/error</span> {<span style="color:#990073">:malformed-let-expression</span> <span style="color:#008080">detail</span>})))))
</span></span><span style="display:flex;"><span>    (<span style="color:#900;font-weight:bold">process-arg-body</span> <span style="color:#008080">args</span>)))
</span></span></code></pre></div><p>Joxa在语法上直接定义为Lisp风格，因此在Macro的定义及使用上面，与传统一脉相承并无修改。在这个Macro定义里面，除了Pattern Matching，以及递归调用<code>process-arg-body</code>之外，与传统Lisp语言并无不同，熟悉传统Lisp的人可以很快就读懂。对比的来看，在Elixir这样的非Lisp语言中引入Macro，由于上层语言的语法与AST并不一致，所以程序员必需记住/区分上层语言与AST两种环境，因此相对较为复杂，比如，在Elixir Macro的签名处Pattern Matching Erlang AST，就在以Elixir的语法编写的Macro定义中，暴露了底层的AST格式。这种复杂性虽然从设计上来说是必需的折衷，但在习惯了Lisp Macro的人看来可能不会太喜欢。Joxa作者Eric在2015年一次接受《This is not a Monad tutorial》的<a href="https://medium.com/this-is-not-a-monad-tutorial/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-a09b15f53a2f">采访</a>中就表示过不喜欢Elixir Macro的复杂性。</p>

<h3 id="27-标准库概览">2.7 标准库概览&nbsp;<a class="headline-hash no-text-decoration" href="#27-%e6%a0%87%e5%87%86%e5%ba%93%e6%a6%82%e8%a7%88">#</a></h3>


<p>Joxa的标准库只包括少数几个基本函数以及对OTP的简单包装。详细列出如下：</p>
<ul>
<li><code>joxa-core</code><br>
基本操作: <code>!=</code>, <code>lte</code>, <code>gte</code>, <code>and</code>, <code>or</code>, <code>+</code>, <code>-</code>, <code>incr</code>, <code>decr</code>, <code>if</code>, <code>when</code>, <code>unless</code>, <code>try</code>, <code>let</code>, <code>define</code></li>
<li><code>joxa-eunit</code><br>
eunit相关函数封装</li>
<li><code>joxa-lists</code><br>
list相关的功能函数： <code>dolist</code>, <code>hd</code>, <code>tl</code>, <code>foldl</code>, <code>map</code>, <code>lists-binding</code>, <code>#</code>, <code>all</code>, <code>any</code></li>
<li><code>joxa-records</code><br>
Record相关函数</li>
<li><code>joxa-shell</code><br>
REPL函数的简单实现</li>
<li><code>joxa-otp</code>, <code>joxa-otp-gen-server</code>, <code>joxa-otp-supervisor</code>, <code>joxa-otp-application</code><br>
Erlang OTP相关接口的封装函数</li>
</ul>
<p>代码规模很小，跟Elixir的标准库相比差得很远。其功能比较简陋，称之为标准库也许太大，或者称之为帮助函数更加准确。由于Joxa可以直接调用Erlang代码，因此功能缺失之处可由其它Erlang库补充。</p>

<h3 id="28-开发环境及工具链">2.8 开发环境及工具链&nbsp;<a class="headline-hash no-text-decoration" href="#28-%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e5%8f%8a%e5%b7%a5%e5%85%b7%e9%93%be">#</a></h3>


<p>目前Joxa只有一个名为<code>joxa</code>的命令行工具，用于编译Joxa源代码，启动REPL，这个工具的功能也比较简陋，跟Clojure的REPL还有很大的距离。源代码中有一个Emacs的Major Mode配置文件<code>emacs/joxa-mode.el</code>，可以在用Emacs开发Joxa时设置缩进，关键字高亮，键绑定等。上面提到的与Slime和Swank集成，则尚未开发。</p>

<h3 id="29-项目状态">2.9 项目状态&nbsp;<a class="headline-hash no-text-decoration" href="#29-%e9%a1%b9%e7%9b%ae%e7%8a%b6%e6%80%81">#</a></h3>


<p>Joxa从2011年底开始开发，一直到2013年初都比较活跃，这之后代码提交量变得相当少，在当前这个时间点(2015年8月)回头看看提交日志，已经有一年多的时间没有任何更新。虽然还未完成原来的设计目标，wiki上面的计划也有很多开发要做，但是由于作者Eric工作上比较忙，而Joxa社区实在太弱小，除作者之外并没有其它的人员贡献过大量代码，因此短期之内似乎项目状态不会重新变得活跃。在Google Group上有Joxa的邮件组，在近一年多时间内也相当少人发言。在应用上，除了作者Eric将Joxa用于编写他的创业项目之外，目前市面上没有看到其它的应用<a href="#17">[17]</a>。综合来看，Joxa的项目状态是比较停滞的。</p>

<h2 id="3-总结">3. 总结&nbsp;<a class="headline-hash no-text-decoration" href="#3-%e6%80%bb%e7%bb%93">#</a></h2>


<p>Joxa是一种基于Erlang VM的现代Lisp语言，有着简洁清晰的Lisp语法，支持强大的Macro，是在Erlang VM编写DSL的一个很好的载体，它无缝兼容Erlang VM平台，是一门功能全面的通用编程语言。它在语言设计及编译器实现方面质量优良，但目前完成度不高，工具链并不完整，市面上也少见应用。作为一门较新的基于Erlang VM的编程语言，它有待进一步的发展完善。</p>
<p><em>注：</em><br>
<!-- raw HTML omitted -->[1]<!-- raw HTML omitted --> Eric Merritt是《Erlang and OTP in Action》(中文译本《Erlang/OTP并发编程实战》)一书的作者之一，Erlware项目联合创始人，Afiniate公司的CTO。<br>
<!-- raw HTML omitted -->[2]<!-- raw HTML omitted --> 翻译自邮件原文<br>
It doesn’t actually mean anything. Many years ago it was an acronym for some project I wanted to start ‘Java oriented something or other’. I never made that project but I bought the domain and have kept it these years. Four letter domains are pretty uncommon these days, so I just decided to use it as the name for the language. Thats all.<br>
<!-- raw HTML omitted -->[3]<!-- raw HTML omitted --> 作为Erlang语言联合创始人以及Joe Armstrong的长期亲密战友，Robert Virding自从当年在爱立信计算机科学实验室开始，长期以来在Erlang的设计，标准库，编译器，发展推广等方方面面都做了杰出的贡献。<br>
<!-- raw HTML omitted -->[4]<!-- raw HTML omitted --> Lisp-1和Lisp-2的区别在于函数与变量是否共用同一命名空间，一个详细的解释可以参考文章<a href="http://ergoemacs.org/emacs/lisp1_vs_lisp2.html">《What&rsquo;s Lisp-1, What&rsquo;s Lisp-2? Bad Jargon or Good Jargon?》</a><br>
<!-- raw HTML omitted -->[5]<!-- raw HTML omitted --> REPL是Read-Eval-Print Loop的缩写，最早被用于指代开发Lisp程序过程中，交互式命令行不断执行读取程序员的输入代码，对其进行求值并打印出求值结果的循环动作。后来这个概念被Python，Ruby及各种交互式命令行工具吸收并推广开来。<br>
<!-- raw HTML omitted -->[6]<!-- raw HTML omitted --> Tony Arcieri是一位美国的软件工程师，他的博客见<a href="http://tonyarcieri.com/">这里</a>。<br>
<!-- raw HTML omitted -->[7]<!-- raw HTML omitted --> José Valim是一位波兰的软件工程师，他最被人熟知的两个身份是Ruby On Rails的核心成员以及Elixir编程语言的创始人。<br>
<!-- raw HTML omitted -->[8]<!-- raw HTML omitted --> 比如Joe Armstrong于2013年中写了博客文章<a href="http://joearms.github.io/2013/05/31/a-week-with-elixir.html">《A Week with Elixir》</a>盛赞了Elixir“结合了Ruby和Erlang的优良特性”，Dave Thomas于2014年发布了新书<a href="https://pragprog.com/book/elixir/programming-elixir">《Programming Elixir》</a>向有其它语言经验的程序员提供了一本系统的教程。<br>
<!-- raw HTML omitted -->[9]<!-- raw HTML omitted --> 译者注：<a href="https://common-lisp.net/project/slime/">Slime</a>是Superior Lisp Interaction Mode for Emacs的缩写，它为Emacs提供了一整套交互式开发Common Lisp的功能集，包括编译，调试，文档查找等等，Slime是客户端，Swank是对应的服务器端，它们共同组成了一个强大的程序开发环境。<br>
<!-- raw HTML omitted -->[10]<!-- raw HTML omitted --> 译者注：<a href="http://erlang.org/doc/man/leex.html">Leex</a>和<a href="http://erlang.org/doc/man/yecc.html">Yecc</a>是Erlang语言的Lex和Yacc工具集。<br>
<!-- raw HTML omitted -->[11]<!-- raw HTML omitted --> CLOS是the Common Lisp Object System的缩写，是指在Common Lisp中实现面向对象机制的一系列代码库。<br>
<!-- raw HTML omitted -->[12]<!-- raw HTML omitted --> 此图来自编译领域的经典著作《Compilers: Principles, Techniques, &amp; Tools》第三版，中译本《编译原理》。<br>
<!-- raw HTML omitted -->[13]<!-- raw HTML omitted --> 这个例子来自Eric Merritt 2012年8月在Chicago Erlang User Group上的技术分享《Joxa: A Full Featured Lisp on the Erlang VM》，录像视频见<a href="https://vimeo.com/49116180">这里</a>.<br>
<!-- raw HTML omitted -->[14]<!-- raw HTML omitted --> LALR是LookAhead LR的缩写，LR中的L表示对输入进行从左到右的扫描，R表示反向构造出一个最右的推导序列。LALR是流行的自底向上语法分析方法。<br>
<!-- raw HTML omitted -->[15]<!-- raw HTML omitted --> PEG是Packrat Expression Parsing的缩写，它是一种相对较新的自顶向下语法分析方法。<br>
<!-- raw HTML omitted -->[16]<!-- raw HTML omitted --> 其中Map的语法支持由我添加，写此文时未进入主干分支。<br>
<!-- raw HTML omitted -->[17]<!-- raw HTML omitted --> 从推广应用的角度来看，在2011年中开始开发的Elixir在各个基于Erlang VM的新编程语言上是走得最前的。</p>


        </div>
    </div>
</article>



                <footer>
                    



    

    

    
        
    

    

    

    

    

    

    


    <section class="backlinks">
        
        <h2 id="backlinks">Backlinks <a class="headline-hash no-text-decoration" href="#backlinks">#</a></h2>
        <nav>
            <ul>
                
                    <li><a href="/minds-echo/">念念不忘，亦有回响</a></li>
                
            </ul>
        </nav>
    </section>









<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#1-erlang-clojure以及joxa">1. Erlang, Clojure以及Joxa</a>
      <ul>
        <li><a href="#11-erlang高并发的函数式容错编程语言">1.1 Erlang，高并发的函数式容错编程语言</a></li>
        <li><a href="#12-clojurejvm上的函数式lisp编程语言">1.2 Clojure，JVM上的函数式Lisp编程语言</a></li>
        <li><a href="#13-joxa-erlang-vm上的新lisp编程语言">1.3 Joxa, Erlang VM上的新Lisp编程语言</a></li>
      </ul>
    </li>
    <li><a href="#2-设计与实现细节">2. 设计与实现细节</a>
      <ul>
        <li><a href="#21-erlang编译过程">2.1 Erlang编译过程</a></li>
        <li><a href="#22--一个简单例子">2.2  一个简单例子</a></li>
        <li><a href="#23-编译器">2.3 编译器</a></li>
        <li><a href="#24-数据类型">2.4 数据类型</a></li>
        <li><a href="#25-特殊form及标准库基础原语">2.5 特殊Form及标准库基础原语</a></li>
        <li><a href="#26-macro">2.6 Macro</a></li>
        <li><a href="#27-标准库概览">2.7 标准库概览</a></li>
        <li><a href="#28-开发环境及工具链">2.8 开发环境及工具链</a></li>
        <li><a href="#29-项目状态">2.9 项目状态</a></li>
      </ul>
    </li>
    <li><a href="#3-总结">3. 总结</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script>(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>




















<div class="backtotop center no-text-decoration clear-float">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__lisp__"
                                
                                
                                title="See all 5 posts categorized in ‘Lisp’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/categories/lisp/">Lisp</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__erlang__"
                                
                                
                                title="See all 4 posts tagged with ‘Erlang’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/tags/erlang/">Erlang</a>
                            </li>
                        
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__clojure__"
                                
                                
                                title="See all 3 posts tagged with ‘Clojure’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/tags/clojure/">Clojure</a>
                            </li>
                        
                    
                        
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__elixir__"
                                
                                
                                title="See all 2 posts tagged with ‘Elixir’"
                                
                            >
                                <a class="p-category" href="https://hhkbp2.com/tags/elixir/">Elixir</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://hhkbp2.com/minds-echo/">«&nbsp;念念不忘，亦有回响</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://hhkbp2.com/all-about-ergodox/">人体工学机械键盘 Ergodox&nbsp;»</a>
        </span>
    
</div>


<a id="bottom"></a>





                       







                    <ul class="no-bullets feed right inline">
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                


<ul class="social no-text-decoration">
    
</ul>











<p class="generated">
    Generated using <a href="https://github.com/gohugoio/hugo"><span class="nobr">Hugo</span></a> +  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> 
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script>var nav=responsiveNav("#nav");</script>





    
    <script defer src="/js/libs/fragmentions/wrapper.min.b19ddbd69b83019e75a4e9bd8b5a027c75675e00329aab620ed1d470c85782ba.js"></script>










            </footer>
        </div> 
    </body>
</html>
